{"version":3,"sources":["webpack:///webpack/bootstrap 9b05d19792b9bf4e2882","webpack:///./mixins/symbols.js","webpack:///./mixins/Symbol.js","webpack:///./mixins/ShadowTemplateMixin.js","webpack:///./mixins/AttributeMarshallingMixin.js","webpack:///./mixins/KeyboardMixin.js","webpack:///./mixins/attributes.js","webpack:///./mixins/SingleSelectionMixin.js","webpack:///./mixins/ContentItemsMixin.js","webpack:///./mixins/DirectionSelectionMixin.js","webpack:///./mixins/KeyboardDirectionMixin.js","webpack:///./mixins/OpenCloseMixin.js","webpack:///./mixins/OverlayMixin.js","webpack:///./mixins/ClickSelectionMixin.js","webpack:///./mixins/DefaultSlotContentMixin.js","webpack:///./mixins/FocusRingMixin.js","webpack:///./mixins/SelectionAriaMixin.js","webpack:///./elements/Dialog.js","webpack:///./elements/Modes.js","webpack:///./mixins/KeyboardPagedSelectionMixin.js","webpack:///./mixins/KeyboardPrefixSelectionMixin.js","webpack:///./mixins/SelectionInViewMixin.js","webpack:///./mixins/TransitionEffectMixin.js","webpack:///./mixins/defaultScrollTarget.js","webpack:///./mixins/renderArrayAsElements.js","webpack:///./mixins/utilities.js","webpack:///./elements/BackdropWrapper.js","webpack:///./elements/FocusCaptureWrapper.js","webpack:///./elements/LabeledTabButton.js","webpack:///./elements/TabStrip.js","webpack:///./elements/TabStripWrapper.js","webpack:///./elements/Tabs.js","webpack:///./mixins/DialogModalityMixin.js","webpack:///./mixins/ShadowReferencesMixin.js","webpack:///./mixins/constants.js","webpack:///./mixins/content.js","webpack:///./mixins/deepContains.js","webpack:///./demos/demos.js","webpack:///./demos/src/BrowserPluginList.js","webpack:///./demos/src/FocusRingTest.js","webpack:///./demos/src/ModesWithKeyboard.js","webpack:///./demos/src/QuietButton.js","webpack:///./demos/src/SampleDialog.js","webpack:///./demos/src/SingleSelectionDemo.js","webpack:///./demos/src/ToolbarTab.js","webpack:///./elements/AlertDialog.js","webpack:///./elements/Drawer.js","webpack:///./elements/LabeledTabs.js","webpack:///./elements/ListBox.js","webpack:///./elements/Popup.js","webpack:///./elements/Toast.js","webpack:///./globals.js","webpack:///./mixins/PopupModalityMixin.js","webpack:///./mixins/SelectedItemTextValueMixin.js"],"names":["symbols","afterEffect","applyEffect","beforeEffect","content","contentChanged","currentEffect","defaults","elementsWithTransitions","getItemText","goDown","goEnd","goLeft","goRight","goStart","goUp","itemAdded","itemsChanged","itemSelected","keydown","openedChanged","orientation","raiseChangeEvents","scrollTarget","showEffect","shadowCreated","template","description","Symbol","uniqueString","count","ShadowTemplateMixin","mapTagToTemplate","Base","ShadowTemplate","tag","localName","console","warn","templateText","document","createElement","innerHTML","window","ShadyCSS","nativeShadow","prepareTemplate","root","attachShadow","mode","clone","importNode","appendChild","styleElement","AttributeMarshallingMixin","attributes","attributeToPropertyNames","propertyNamesToAttributes","AttributeMarshalling","attributeName","oldValue","newValue","propertyName","attributeToPropertyName","element","writePendingAttributes","attribute","value","setAttribute","className","setClass","elementClass","attributesForClass","classFn","prototype","HTMLElement","baseClass","Object","getPrototypeOf","constructor","baseAttributes","observedAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","set","map","propertyNameToAttribute","setterName","diff","indexOf","concat","hyphenRegEx","replace","match","toUpperCase","uppercaseRegEx","toLowerCase","KeyboardMixin","Keyboard","addEventListener","handled","event","preventDefault","stopPropagation","getAttribute","tabindex","toggleClass","utilities","safeToSetAttributesKey","pendingAttributesKey","pendingClassesKey","reflectAttributeToElement","classList","addClass","contains","add","remove","pendingAttributes","pendingClasses","removeAttribute","text","String","webkitForceStyleUpdate","SingleSelectionMixin","canSelectNextKey","canSelectPreviousKey","selectionRequiredKey","selectionWrapsKey","externalSelectedIndexKey","externalSelectedItemKey","internalSelectedIndexKey","internalSelectedItemKey","SingleSelection","selectionRequired","selectionWraps","item","selectedItem","trackSelectedItem","updatePossibleNavigations","selected","selectIndex","items","length","selectedIndex","newIndex","canSelectNext","changed","dispatchEvent","CustomEvent","canSelectPrevious","index","parsedIndex","parseInt","hasItems","detail","previousSelectedItem","Array","call","parsed","boundedIndex","Math","max","min","previousIndex","itemCount","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","ContentItemsMixin","itemsKey","itemInitializedKey","ContentItems","forEach","substantiveElements","DirectionSelectionMixin","DirectionSelection","selectNext","selectLast","selectPrevious","selectFirst","KeyboardDirectionMixin","KeyboardDirection","horizontal","vertical","keyCode","metaKey","altKey","OpenCloseMixin","closePromiseKey","closeResolveKey","closeResultKey","openedKey","openPromiseKey","openResolveKey","OpenClose","createOpenPromise","createClosePromise","opened","effect","resolveClose","resolveOpen","result","parsedOpened","Promise","resolve","reject","OverlayMixin","appendedToDocumentKey","forceAppendToBodyKey","placeholderKey","previousFocusedElementKey","previousZIndexKey","Overlay","makeVisible","style","zIndex","parentNode","removeChild","replaceChild","focus","activeElement","isElementInBody","body","teleportToBodyOnOpen","createPlaceholder","getComputedStyle","computedZIndex","position","maxZIndexInUse","message","placeholder","createComment","visible","elements","querySelectorAll","zIndices","isNaN","ClickSelectionMixin","ClickSelection","button","target","composedPath","itemForTarget","DefaultSlotContentMixin","slotchangeFiredKey","DefaultSlotContent","setTimeout","slot","defaultSlot","assignedNodes","flatten","e","shadowRoot","querySelector","FocusRingMixin","focusedWithKeyboard","previousFocusedWithKeyboard","listeningToWindowFocus","FocusRing","windowFocused","SelectionAria","role","itemRole","id","baseId","idCount","itemId","Dialog","filler","customElements","define","Modes","display","KeyboardPagedSelectionMixin","KeyboardPagedSelection","pageUp","pageDown","scrollOnePage","getIndexOfItemAtY","y","downward","start","end","step","topOfClientArea","offsetTop","clientTop","itemIndex","itemTop","found","itemBottom","offsetHeight","itemStyle","itemPaddingTop","paddingTop","parseFloat","itemPaddingBottom","paddingBottom","contentTop","contentBottom","clientHeight","edge","scrollTop","indexOfItemAtEdge","delta","KeyboardPrefixSelectionMixin","itemTextContentsKey","typedPrefixKey","prefixTimeoutKey","settingSelectionKey","KeyboardPrefixSelection","textContent","resetTypedPrefix","resetPrefix","handleBackspace","ctrlKey","which","handlePlainCharacter","fromCharCode","prefix","getIndexOfItemWithTextPrefix","itemTextContents","getItemTextContents","prefixLength","i","itemTextContent","substr","selectItemWithTextPrefix","setPrefixTimeout","char","resetPrefixTimeout","clearTimeout","TYPING_TIMEOUT_DURATION","SelectionInView","scrollItemIntoView","scrollTargetRect","getBoundingClientRect","itemRect","bottomDelta","bottom","topDelta","top","leftDelta","left","rightDelta","right","ceil","scrollLeft","TransitionEffectMixin","enableEffectsKey","transitionendListenerKey","TransitionEffect","getTransitionElements","removeEventListener","base","animationEndPromise","animationStartPromise","requestAnimationFrame","then","prefersReducedMotion","matchMedia","matches","applyPromise","defaultScrollTarget","scrollingParent","getScrollingParent","DocumentFragment","overflowX","overflowY","renderArrayAsElements","container","renderItem","oldElement","children","newElement","webkitUserSelectKey","browserVersionMatch","exec","navigator","userAgent","needsForceFix","test","vendor","webkitUserSelect","effectiveWebkitUserSelect","BackdropWrapper","Backdrop","FocusCaptureWrapper","wrappingFocusKey","FocusCapture","shiftKey","focusCatcher","LabeledTabButton","tabAlignKey","tabPositionKey","TabStrip","tabAlign","tabPosition","reflectAttribute","navigationAxis","tab","TabStripWrapper","TabStripWrap","tabStrip","fillers","defaultFiller","default","tabButtonsFiller","tabButtons","topOrLeft","firstElement","pages","lastElement","nextSibling","insertBefore","Tabs","DialogModalityMixin","previousBodyOverflowKey","previousDocumentMarginRightKey","DialogModality","overflow","documentElement","marginRight","scrollBarWidth","innerWidth","clientWidth","close","ShadowReferencesMixin","ShadowReferences","$","nodesWithIds","node","constants","nodes","auxiliaryElementTags","Element","deepContains","current","host","Elix","BrowserPluginList","choices","plugins","plugin","name","sorted","sort","setOptions","options","divs","div","option","FocusRingTest","ModesWithKeyboard","QuietButton","SampleDialog","SingleSelectionDemo","ToolbarTab","choicesKey","AlertDialog","buttonContainer","charCodeAt","buttonFiller","buttons","choice","Drawer","direction","dir","backdrop","LabeledTabs","tabPanel","tabButton","ListBox","Popup","durationKey","fromEdgeKey","timeoutKey","Toast","clearTimer","startTimer","duration","fromEdge","SelectionAriaMixin","SelectionInViewMixin","assign","PopupModalityMixin","closeListenerKey","PopupModality","insideEvent","Node","SelectedItemTextValueMixin","SelectedItemTextValue","currentIndex"],"mappings":"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","file":"demos.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 53);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9b05d19792b9bf4e2882","import Symbol from './Symbol.js';\n\n\n/**\n * A collection of (potentially polyfilled) `Symbol` objects for standard\n * component properties and methods.\n *\n * These `Symbol` objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these `Symbol` objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix/mixins/SingleSelectionMixin';\n *     import 'symbols' from 'elix/mixins/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * To support Internet Explorer 11, which does not have support for the\n * `Symbol` class, you can use the [Symbol](Symbol) helper, or a `Symbol`\n * polyfill of your choice.\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `afterEffect` method.\n   * \n   * This method is invoked after a visual effect has completed. Implement\n   * this method to perform any necessary cleanup.\n   * \n   * @param {string} effect - The name of the effect that has completed\n   */\n  afterEffect: Symbol('afterEffect'),\n\n  /**\n   * Symbol for the `applyEffect` method.\n   * \n   * This method is invoked to trigger the execution of a visual effect.\n   * \n   * @param {string} effect - The name of the effect to apply\n   * @returns {Promise} A Promise that resolves when the effect completes\n   */\n  applyEffect: Symbol('applyEffect'),\n\n  /**\n   * Symbol for the `beforeEffect` method.\n   * \n   * This method is invoked before a visual effect has begun. Implement this\n   * method to prepare the element for the effect.\n   * \n   * @param {string} effect - The name of the effect that has completed\n   */\n  beforeEffect: Symbol('beforeEffect'),\n\n  /**\n   * Symbols for the `content` property.\n   *\n   * This property returns the component's content -- however the component\n   * wants to define that. This could, for example, return the component's\n   * distributed children.\n   *\n   * @type {HTMLElement[]}\n   */\n  content: Symbol('content'),\n\n  /**\n   * Symbol for the `contentChanged` method.\n   *\n   * For components that define a `content` property, this method should be\n   * invoked when that property changes.\n   *\n   * @function contentChanged\n   */\n  contentChanged: Symbol('contentChanged'),\n\n  /**\n   * The name of the visual effect currently begin shown.\n   * \n   * @returns {string}\n   */\n  currentEffect: Symbol('currentEffect'),\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: Symbol('defaults'),\n\n  /**\n   * Symbol for the `elementsWithTransitions` property.\n   * \n   * A component can implement this method to indicate which element(s) have CSS\n   * transitions that will be triggered if the given effect is shown.\n   * \n   * @param {string} effect - The effect under consideration\n   * @returns {[HTMLElement]} The elements with CSS transitions\n   */\n  elementsWithTransitions: Symbol('elementsWithTransitions'),\n\n  /**\n   * Symbol for the `getItemText` method.\n   *\n   * This method can be applied to an item to return its text.\n   *\n   * @function getItemText\n   * @param {HTMLElement} item - the item to extract text from\n   * @returns {string} the text of the item\n   */\n  getItemText: Symbol('getText'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: Symbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: Symbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: Symbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: Symbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: Symbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: Symbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: Symbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   *\n   * @function itemsChanged\n   */\n  itemsChanged: Symbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: Symbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: Symbol('keydown'),\n\n  /**\n   * Symbol for the `openedChanged` method.\n   * \n   * This method is invoked when the `opened` property has changed. There are\n   * two advantages to using `openedChanged` rather than implementing a setter\n   * for the `opened` property: 1) `openedChanged` will supply the _parsed_\n   * value of the `opened` property, whereas the `opened` property might be\n   * passed a string as an attribute value, and 2) `openedChanged` only executes\n   * when the value of `opened` has actually changed.\n   * \n   * @param {boolean} opened - The new value of the `opened` property\n   */\n  openedChanged: Symbol('openedChanged'),\n\n  /**\n   * Indicates the general horizontal and/or vertical orientation of the\n   * component. This may affect both presentation and behavior (e.g., of\n   * keyboard navigation).\n   *\n   * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n   *\n   * @type {string}\n   */\n  orientation: Symbol('orientation'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. For a detailed discussion\n   * of this point, see the Gold Standard checklist item for\n   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n   *\n   * The above article describes a pattern for using a flag to track whether\n   * work is being performed in response to internal component activity, and\n   * whether the component should therefore raise property change events.\n   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n   * all Elix mixins and components. Sharing this flag ensures that internal\n   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n   * handling affected properties to raise change events.\n   *\n   * All UI event listeners (and other forms of internal handlers, such as\n   * timeouts and async network handlers) should set `raiseChangeEvents` to\n   * `true` at the start of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   * @var {boolean} raiseChangeEvents\n   */\n  raiseChangeEvents: Symbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `scrollTarget` property.\n   *\n   * This property indicates which element in a component's shadow subtree\n   * should be scrolled. [SelectionInViewMixin](SelectionInViewMixin) can use\n   * this property to determine which element should be scrolled to keep the\n   * selected item in view.\n   *\n   * @var {HTMLElement} scrollTarget\n   */\n  scrollTarget: Symbol('scrollTarget'),\n\n  /**\n   * Symbol for the `showEffect` method.\n   * \n   * This method invokes an asynchronous visual effect. It will invoke\n   * the `beforeEffect`, `applyEffect`, and `afterEffect` methods in\n   * turn. The first and last of those are synchronous, but `applyEffect`\n   * is asynchronous.\n   * \n   * @param {string} effect - The name of the effect that has completed\n   */\n  showEffect: Symbol('showEffect'),\n\n  /**\n   * Symbol for the `shadowCreated` method.\n   *\n   * This method is invoked when the component's shadow root has been attached\n   * and populated. Other code can handle this method to perform initialization\n   * that depends upon the existence of a populated shadow subtree.\n   *\n   * @function shadowCreated\n   */\n  shadowCreated: Symbol('shadowCreated'),\n\n  /**\n   * Symbol for the `template` method.\n   *\n   * This method should return a component's template.\n   *\n   * @param {string|object} [filler]\n   * @type {string|HTMLTemplateElement}\n   */\n  template: Symbol('template')\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/symbols.js","/* The number of fake symbols we've served up */\nlet count = 0;\n\n/**\n * @param {any} description\n * @returns {string}\n */\nfunction uniqueString(description) {\n  return `_${description}${count++}`;\n}\n\n/**\n * A helper function for simulating instances of the `Symbol` class in older\n * browsers, notably Microsoft Internet Explorer 11.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. Elix uses `Symbol` instances as property keys to set and\n * retrieve data on an element. This prevents accidental name collisions. While\n * it does not make the properties completely private, it does make them\n * somewhat harder to access, and hopefully discourages outside code from\n * directly manipulating the properties.\n *\n * In modern browsers that support `Symbol`, the Elix `Symbol` helper function\n * simply returns a real `Symbol` instance. In browsers like IE that do not have\n * support for `Symbol`, the Elix `Symbol` helper function returns a different\n * string each time it is called.\n *\n * Usage:\n *\n *     const fooKey = Symbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooKey];\n *       }\n *       set foo(value) {\n *         this[fooKey] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property that looks\n * like `this._foo0`, `this._foo1`, etc. The underscore is meant to reduce (not\n * eliminate) potential accidental access, and the unique number at the end is\n * mean to avoid (not eliminate) naming conflicts.\n *\n * @function Symbol\n * @param {any} description - A string to identify the symbol when debugging\n * @returns {symbol|string} - A Symbol (in ES6 browsers) or unique string ID (in\n * ES5).\n */\nexport default function(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    uniqueString(description);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/Symbol.js","import symbols from './symbols.js';\n\n\n// A cache of processed templates.\n//\n// We maintain this as a map keyed by element tag (localName). We could store\n// an element's processed template on its element prototype. One scenario that\n// wouldn't support would be registration of the same constructor under multiple\n// tag names, which was a (perhaps theoretical) use case for Custom Elements.\n//\nconst mapTagToTemplate = {};\n\n/**\n * Mixin which adds stamping a template into a Shadow DOM subtree upon component\n * instantiation.\n *\n * To use this mixin, define a `template` method that returns a string or HTML\n * `<template>` element:\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       [symbols.template]() {\n *         return `Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` method, this\n * mixin has no effect.\n *\n * @module ShadowTemplateMixin\n */\nexport default function ShadowTemplateMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class ShadowTemplate extends Base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      // @ts-ignore\n      super();\n\n      const tag = this.localName;\n      let template = tag && mapTagToTemplate[tag];\n\n      // See if we've already processed a template for this tag.\n      if (!template) {\n        // This is the first time we've created an instance of this tag.\n\n        // Get the template and perform initial processing.\n        template = this[symbols.template]();\n        if (!template) {\n          console.warn(`ShadowTemplateMixin expects a component to define a method called [symbols.template].`);\n          return;\n        }\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          const templateText = template;\n          template = document.createElement('template');\n          template.innerHTML = templateText;\n          \n          // A polyfill bug under IE\n          // (probably https://github.com/webcomponents/webcomponentsjs/issues/474)\n          // prevents the template's innerHTML from being set properly if it\n          // contains other elements. We check to make sure the assignment stuck.\n          if (template.innerHTML !== templateText) {\n            template.innerHTML = templateText;\n          }\n        }\n\n        // @ts-ignore\n        if (window.ShadyCSS && !window.ShadyCSS.nativeShadow) {\n          // Let the CSS polyfill do its own initialization.\n          // @ts-ignore\n          window.ShadyCSS.prepareTemplate(template, tag);\n        }\n\n        if (tag) {\n          // Store this for the next time we create the same type of element.\n          mapTagToTemplate[tag] = template;\n        }\n      }\n\n      // Stamp the template into a new shadow root.\n      const root = this.attachShadow({ mode: 'open' });\n      const clone = document.importNode(template.content, true);\n      root.appendChild(clone);\n\n      /* Let the component know the shadow tree has been populated. */\n      if (this[symbols.shadowCreated]) {\n        this[symbols.shadowCreated]();\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // @ts-ignore\n      if (window.ShadyCSS && !window.ShadyCSS.nativeShadow) {\n        // @ts-ignore\n        window.ShadyCSS.styleElement(this);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/ShadowTemplateMixin.js","import * as attributes from './attributes.js';\n\n\n// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\n/**\n * Mixin which marshalls attributes to properties and vice versa.\n *\n * If your component exposes a setter for a property, it's generally a good\n * idea to let devs using your component be able to set that property in HTML\n * via an element attribute. You can code that yourself by writing an\n * `attributeChangedCallback`, or you can use this mixin to get a degree of\n * automatic support.\n *\n * This mixin implements an `attributeChangedCallback` that will attempt to\n * convert a change in an element attribute into a call to the corresponding\n * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n * respects that convention, automatically mapping the hyphenated attribute\n * name to the corresponding camelCase property name.\n *\n * Example: You define a component using this mixin:\n *\n *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n *       get fooBar() { return this._fooBar; }\n *       set fooBar(value) { this._fooBar = value; }\n *     }\n *     customElements.define('my-element', MyElement);\n *\n * If someone then instantiates your component in HTML:\n *\n *     <my-element foo-bar=\"Hello\"></my-element>\n *\n * Then, after the element has been upgraded, the `fooBar` setter will\n * automatically be invoked with the initial value \"Hello\".\n *\n * Attributes can only have string values. If you'd like to convert string\n * attributes to other types (numbers, booleans), you must implement parsing\n * yourself.\n *\n * This mixin also exposes helpers for reflecting attributes and classes to\n * the element. These helpers can be invoked during a component's constructor;\n * any attributes or classes set during the constructor are applied when the\n * component's `connectedCallback` is invoked.\n *\n * @module AttributeMarshallingMixin\n */\nexport default function AttributeMarshallingMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class AttributeMarshalling extends Base {\n\n    /**\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      if (propertyName in this) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Reflect any attributes set during constructor.\n      /** @type {any} */\n      const element = this;\n      attributes.writePendingAttributes(element);\n    }\n\n    static get observedAttributes() {\n      /** @type {any} */\n      const elementClass = this;\n      return attributesForClass(elementClass);\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {string|boolean|number} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      /** @type {any} */\n      const element = this;\n      return attributes.setAttribute(element, attribute, value);\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {boolean} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      /** @type {any} */\n      const element = this;\n      return attributes.setClass(element, className, value);\n    }\n\n  }\n\n  return AttributeMarshalling;\n}\n\n\n/**\n * Return the custom attributes for the given class.\n */\nfunction attributesForClass(classFn) {\n\n  // We treat the HTMLElement base class as if it has no attributes, since we\n  // don't want to receive attributeChangedCallback for it. We'd like to do\n  // a simple check if classFn === HTMLElement, but this fails in the polyfill\n  // under IE, so we compare prototypes instead.\n  if (classFn.prototype === HTMLElement.prototype) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  // See if parent class defines observedAttributes manually.\n  let baseAttributes = baseClass.observedAttributes;\n  if (!baseAttributes) {\n    // Calculate parent class attributes ourselves.\n    baseAttributes = attributesForClass(baseClass);\n  }\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n        classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n/**\n * Convert hyphenated foo-bar attribute name to camel case fooBar property name.\n */\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hyphenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hyphenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\n/**\n * Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\n */\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/AttributeMarshallingMixin.js","import symbols from './symbols.js';\n\n\n/**\n * Mixin which manages the keydown handling for a component.\n *\n * This mixin handles several keyboard-related features.\n *\n * First, it wires up a single keydown event handler that can be shared by\n * multiple mixins on a component. The event handler will invoke a `keydown`\n * method with the event object, and any mixin along the prototype chain that\n * wants to handle that method can do so.\n *\n * If a mixin wants to indicate that keyboard event has been handled, and that\n * other mixins should *not* handle it, the mixin's `keydown` handler should\n * return a value of true. The convention that seems to work well is that a\n * mixin should see if it wants to handle the event and, if not, then ask the\n * superclass to see if it wants to handle the event. This has the effect of\n * giving the mixin that was applied last the first chance at handling a\n * keyboard event.\n *\n * Example:\n *\n *     [symbols.keydown](event) {\n *       let handled;\n *       switch (event.keyCode) {\n *         // Handle the keys you want, setting handled = true if appropriate.\n *       }\n *       // Prefer mixin result if it's defined, otherwise use base result.\n *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n *     }\n *\n * Until iOS Safari supports the `KeyboardEvent.key` property\n * (see http://caniuse.com/#search=keyboardevent.key), mixins should generally\n * test keys using the legacy `keyCode` property, not `key`.\n *\n * A second feature provided by this mixin is that it implicitly makes the\n * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n * has the effect of adding the component to the tab order in document order.\n *\n * @module KeyboardMixin\n */\nexport default function KeyboardMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class Keyboard extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n      this.addEventListener('keydown', event => {\n        this[symbols.raiseChangeEvents] = true;\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @returns {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n      return false;\n    }\n\n  }\n\n  return Keyboard;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/KeyboardMixin.js","/**\n * These are helper functions for accessing a component's attributes.\n *\n * @module attributes\n */\n\n\nimport Symbol from './Symbol.js';\nimport * as utilities from './utilities.js';\n\n\n// Symbols for private data members on an element.\nconst safeToSetAttributesKey = Symbol('safeToSetAttributes');\nconst pendingAttributesKey = Symbol('pendingAttributes');\nconst pendingClassesKey = Symbol('pendingClasses');\n\n\n/**\n * Set/unset the attribute with the indicated name.\n *\n * This method exists primarily to handle the case where an element wants to\n * set a default property value that should be reflected as an attribute. An\n * important limitation of custom element consturctors is that they cannot\n * set attributes. A call to `setAttribute` during the constructor will\n * be deferred until the element is connected to the document.\n *\n * @param {Element} element - The element to modify.\n * @param {string} attribute - The name of the *attribute* (not property) to set.\n * @param {string|boolean|number} value - The value to set. If null, the attribute will be removed.\n */\nexport function setAttribute(element, attribute, value) {\n  if (element[safeToSetAttributesKey]) {\n    // Safe to set attributes immediately.\n    reflectAttributeToElement(element, attribute, value);\n  } else {\n    // Defer setting attributes until the first time we're connected.\n    if (!element[pendingAttributesKey]) {\n      element[pendingAttributesKey] = {};\n    }\n    element[pendingAttributesKey][attribute] = value;\n  }\n}\n\n\n/**\n * Set/unset the class with the indicated name.\n *\n * This method exists primarily to handle the case where an element wants to\n * set a default property value that should be reflected as as class. An\n * important limitation of custom element consturctors is that they cannot\n * set attributes, including the `class` attribute. A call to\n * `setClass` during the constructor will be deferred until the element\n * is connected to the document.\n *\n * @param {Element} element - The element to modify.\n * @param {string} className - The name of the class to set/unset.\n * @param {boolean} [value] - True to set the class, false to remove it. If\n * omitted, the class will be toggled.\n */\nexport function setClass(element, className, value) {\n  if (element[safeToSetAttributesKey]) {\n    // Safe to set class immediately.\n    return toggleClass(element, className, value);\n  } else {\n    // Defer setting class until the first time we're connected.\n    if (!element[pendingClassesKey]) {\n      element[pendingClassesKey] = {};\n    }\n    element[pendingClassesKey][className] = value;\n    return value;\n  }\n}\n\n\n/**\n * Immediately toggle the indicated class.\n * \n * This method exists only to support IE 11, whose `classList.toggle`\n * implementation is deficient.\n *\n * @param {Element} element - The element to modify.\n * @param {string} className - The name of the class to set/unset.\n * @param {boolean} [value] - True to set the class, false to remove it. If\n * omitted, the class will be toggled.\n */\nexport function toggleClass(element, className, value) {\n  const classList = element.classList;\n  const addClass = typeof value === 'undefined' ?\n    !classList.contains(className) :\n    value;\n  if (addClass) {\n    classList.add(className);\n  } else {\n    classList.remove(className);\n  }\n  return addClass;\n}\n\n\n/**\n * Perform any pending updates to attributes and classes.\n *\n * This writes any `setAttribute` or `setClass` values that were performed\n * before an element was attached to the document for the first time.\n *\n * This method should be called by mixins/components in their\n * `connectedCallback`. If mulitple mixins/components invoke this during the\n * same `connectedCallback`, only the first call will have any effect. The\n * subsequent calls will be harmless.\n *\n * @param {HTMLElement} element - The element being added to the document.\n */\nexport function writePendingAttributes(element) {\n  element[safeToSetAttributesKey] = true;\n\n  // Set any pending attributes.\n  const pendingAttributes = element[pendingAttributesKey];\n  if (pendingAttributes) {\n    for (let attribute in pendingAttributes) {\n      const value = pendingAttributes[attribute];\n      reflectAttributeToElement(element, attribute, value);\n    }\n    element[pendingAttributesKey] = null;\n  }\n\n  // Set any pending classes.\n  const pendingClasses = element[pendingClassesKey];\n  if (pendingClasses) {\n    for (let className in pendingClasses) {\n      const value = pendingClasses[className];\n      toggleClass(element, className, value);\n    }\n    element[pendingClassesKey] = null;\n  }\n}\n\n\n//\n// Helpers\n//\n\n// Reflect the attribute to the given element.\n// If the value is null, remove the attribute.\nfunction reflectAttributeToElement(element, attributeName, value) {\n  if (value === null || typeof value === 'undefined') {\n    element.removeAttribute(attributeName);\n  } else {\n    const text = String(value);\n    // Avoid recursive attributeChangedCallback calls.\n    if (element.getAttribute(attributeName) !== text) {\n      element.setAttribute(attributeName, value);\n    }\n  }\n  utilities.webkitForceStyleUpdate(element);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/attributes.js","import Symbol from './Symbol.js';\nimport symbols from './symbols.js';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextKey = Symbol('canSelectNext');\nconst canSelectPreviousKey = Symbol('canSelectPrevious');\nconst selectionRequiredKey = Symbol('selectionRequired');\nconst selectionWrapsKey = Symbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexKey = Symbol('externalSelectedIndex');\nconst externalSelectedItemKey = Symbol('externalSelectedItem');\nconst internalSelectedIndexKey = Symbol('internalSelectedIndex');\nconst internalSelectedItemKey = Symbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n */\nexport default function SingleSelectionMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class SingleSelection extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextKey];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextKey];\n      this[canSelectNextKey] = canSelectNext;\n      if ('canSelectNext' in Base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousKey];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousKey];\n      this[canSelectPreviousKey] = canSelectPrevious;\n      if ('canSelectPrevious' in Base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {Element} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {Element} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexKey] != null ?\n        this[externalSelectedIndexKey] :\n        -1;\n    }\n    /**\n     * @param {number|string} index\n     */\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexKey];\n      let item;\n      let parsedIndex = typeof index === 'string' ? parseInt(index) : index;\n      if (parsedIndex !== this[externalSelectedIndexKey]) {\n        // Store the new index and the corresponding item.\n        const items = this.items || [];\n        const hasItems = items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexKey] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemKey] = item;\n      } else {\n        item = this[externalSelectedItemKey];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in Base.prototype) { super.selectedIndex = parsedIndex; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexKey] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemKey] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * @type {Element|null}\n     */\n    // REVIEW: Even if selectionRequired is true, caller can still explicitly\n    // set selectedItem to null. In that case, should we leave selection alone,\n    // or set it to null?\n    get selectedItem() {\n      return this[externalSelectedItemKey] || null;\n    }\n    /**\n     * @param {Element|null} item\n     */\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemKey];\n      const changed = item !== previousSelectedItem;\n      /** @type {number} */\n      let index;\n      if (item !== this[externalSelectedItemKey]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexKey] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemKey] = index >= 0 ? item : null;\n      } else {\n        index = this[externalSelectedIndexKey];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in Base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemKey] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexKey] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredKey];\n    }\n    set selectionRequired(selectionRequired) {\n      const parsed = String(selectionRequired) === 'true';\n      const changed = parsed !== this[selectionRequiredKey];\n      this[selectionRequiredKey] = parsed;\n      if ('selectionRequired' in Base.prototype) { super.selectionRequired = selectionRequired; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-required-changed');\n          this.dispatchEvent(event);\n        }\n        if (selectionRequired) {\n          trackSelectedItem(this);\n        }\n      }\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsKey];\n    }\n    set selectionWraps(selectionWraps) {\n      const parsed = String(selectionWraps) === 'true';\n      const changed = parsed !== this[selectionWrapsKey];\n      this[selectionWrapsKey] = parsed;\n      if ('selectionWraps' in Base.prototype) { super.selectionWraps = selectionWraps; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-wraps-changed');\n          this.dispatchEvent(event);\n        }\n        updatePossibleNavigations(this);\n      }\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return this.items ?\n        selectIndex(this, this.items.length - 1) :\n        false;\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      if (this.items) {\n        const newIndex = this.selectedIndex < 0 ?\n          this.items.length - 1 :     // No selection yet; select last item.\n          this.selectedIndex - 1;\n        return selectIndex(this, newIndex);\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n/**\n * Ensure the given index is within bounds, and select it if it's not already\n * selected.\n */\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Following a change in the set of items, or in the value of the\n * `selectionRequired` property, reacquire the selected item. If it's moved,\n * update `selectedIndex`. If it's been removed, and a selection is required,\n * try to select another item.\n */\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (itemCount === 0) {\n    if (previousSelectedItem) {\n      // We've lost the selection, and there's nothing left to select.\n      element.selectedItem = null;\n    }\n  } else if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n/**\n * Following a change in selection, report whether it's now possible to\n * go next/previous from the given index.\n */\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/SingleSelectionMixin.js","import * as content from './content.js';\nimport Symbol from './Symbol.js';\nimport symbols from './symbols.js';\n\n\n// Symbols for private data members on an element.\nconst itemsKey = Symbol('items');\nconst itemInitializedKey = Symbol('itemInitialized');\n\n\n/**\n * Mixin which maps content semantics (nodes) to list item semantics.\n *\n * Items differ from nodes contents in several ways:\n *\n * * They are often referenced via index.\n * * They may have a selection state.\n * * It's common to do work to initialize the appearance or state of a new\n *   item.\n * * Text nodes are filtered out.\n * * Auxiliary invisible child elements are filtered out and not counted as\n *   items. Auxiliary elements include link, script, style, and template\n *   elements. This filtering ensures that those auxiliary elements can be\n *   used in markup inside of a list without being treated as list items.\n *\n * This mixin expects a component to provide a `content` property returning a\n * raw set of elements. You can provide that yourself, or use\n * [DefaultSlotContentMixin](DefaultSlotContentMixin).\n *\n * The most commonly referenced property defined by this mixin is the `items`\n * property. To avoid having to do work each time that property is requested,\n * this mixin supports an optimized mode. If you invoke the `contentChanged`\n * method when the set of items changes, the mixin concludes that you'll take\n * care of notifying it of future changes, and turns on the optimization. With\n * that on, the mixin saves a reference to the computed set of items, and will\n * return that immediately on subsequent calls to the `items` property. If you\n * use this mixin in conjunction with `DefaultSlotContentMixin`, the\n * `contentChanged` method will be invoked for you when the element's children\n * change, turning on the optimization automatically.\n *\n * Most Elix [elements](elements) use `ContentItemsMixin`, including\n * [ListBox](ListBox), [Modes](Modes), and [Tabs](Tabs).\n *\n * @module ContentItemsMixin\n */\nexport default function ContentItemsMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class ContentItems extends Base {\n\n    [symbols.contentChanged]() {\n      if (super[symbols.contentChanged]) { super[symbols.contentChanged](); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsKey] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {Element[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsKey] == null) {\n        items = content.substantiveElements(this[symbols.content]);\n        // Note: test for *equality* with null, since we use `undefined` to\n        // indicate that we're not yet caching items.\n        if (this[itemsKey] === null) {\n          // Memoize the set of items.\n          this[itemsKey] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsKey];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization – since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization if `itemAdded` is defined.\n      if (this[symbols.itemAdded]) {\n        Array.prototype.forEach.call(this.items, item => {\n          if (!item[itemInitializedKey]) {\n            this[symbols.itemAdded](item);\n            item[itemInitializedKey] = true;\n          }\n        });\n      }\n\n      if (this[symbols.raiseChangeEvents]) {\n        this.dispatchEvent(new CustomEvent('items-changed'));\n      }\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/ContentItemsMixin.js","import symbols from './symbols.js';\n\n\n/**\n * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n * semantics (selectPrevious, selectNext, etc.).\n *\n * This mixin can be used in conjunction with\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) (which maps keyboard\n * events to directions) and a mixin that handles selection like\n * [SingleSelectionMixin](SingleSelectionMixin).\n *\n * @module DirectionSelectionMixin\n */\nexport default function DirectionSelectionMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class DirectionSelection extends Base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      if (!this.selectNext) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectNext\" method.`);\n        return false;\n      } else {\n        return this.selectNext();\n      }\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      if (!this.selectLast) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectLast\" method.`);\n        return false;\n      } else {\n        return this.selectLast();\n      }\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      if (!this.selectPrevious) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.`);\n        return false;\n      } else {\n        return this.selectPrevious();\n      }\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      if (!this.selectNext) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectNext\" method.`);\n        return false;\n      } else {\n        return this.selectNext();\n      }\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      if (!this.selectFirst) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectFirst\" method.`);\n        return false;\n      } else {\n        return this.selectFirst();\n      }\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      if (!this.selectPrevious) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.`);\n        return false;\n      } else {\n        return this.selectPrevious();\n      }\n    }\n\n  }\n\n  return DirectionSelection;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/DirectionSelectionMixin.js","import symbols from './symbols.js';\n\n\n/**\n * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n * (go left, go right, etc.).\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin) for that\n * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin calls methods such as `goLeft` and `goRight`. You can define\n * what that means by implementing those methods yourself. If you want to use\n * direction keys to navigate a selection, use this mixin with\n * [DirectionSelectionMixin](DirectionSelectionMixin).\n *\n * If the component defines a property called `symbols.orientation`, the value\n * of that property will constrain navigation to the horizontal or vertical axis.\n *\n * @module KeyboardDirectionMixin\n */\nexport default function KeyboardDirectionMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class KeyboardDirection extends Base {\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    [symbols.keydown](event) {\n      let handled = false;\n\n      const orientation = this[symbols.orientation] || 'both';\n      const horizontal = (orientation === 'horizontal' || orientation === 'both');\n      const vertical = (orientation === 'vertical' || orientation === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event)) || false;\n    }\n\n  }\n\n  return KeyboardDirection;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/KeyboardDirectionMixin.js","import * as attributes from './attributes.js';\nimport Symbol from './Symbol.js';\nimport symbols from './symbols.js';\n\n\n// Symbols for private data members on an element.\nconst closePromiseKey = Symbol('closePromise');\nconst closeResolveKey = Symbol('closeResolve');\nconst closeResultKey = Symbol('closeResult');\nconst openedKey = Symbol('opened');\nconst openPromiseKey = Symbol('openPromise');\nconst openResolveKey = Symbol('openResolve');\n\n\n/**\n * This mixin provides a consistent public API for components that open and\n * close, including overlays and various types of expandable/collapsable\n * elements.\n * \n * The mixin provides the following members:\n * \n * * `opened` property that is true when open, false when closed.\n * * `open`/`close` methods that set the `opened` property and return a promise\n *   for when the open/close action has completed (including any async effects).\n * * `toggle` method which toggles the opened property.\n * * `whenOpened`/`whenClosed` promises for the next time the element\n *   opens/closes.\n * \n * If the component defines the following optional members, the mixin will take\n * advantage of them:\n * \n * * Effect methods compatible with TransitionEffectMixin if the element wants\n *   to define async opening/closing effects. The use of transition effects is\n *   not required. If a component doesn’t use `TransitionEffectMixin` or a\n *   compatible mixin, then `OpenCloseMixin` will perform its work\n *   synchronously, with no transition effects.\n * * `symbols.openedChanged` method that will be invoked when the opened\n *   property changes.\n * \n * The `OpenCloseMixin` is designed to support user interface elements that have\n * two states that can be described as \"opened\" and “closed”. These can be\n * grouped into two top-level categories:\n * \n * 1. Elements that open over other elements — that is, overlays.\n * 2. Elements that expand and collapse inline — these may be panels that open\n *    to reveal more detail, or list items that expand to show more detail or\n *    additional commands.\n * \n * @module OpenCloseMixin\n */\nexport default function OpenCloseMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class OpenClose extends Base {\n\n    constructor() {\n\n      // @ts-ignore\n      super();\n\n      createOpenPromise(this);\n      createClosePromise(this);\n\n      // Set defaults.\n      if (typeof this.opened === 'undefined') {\n        this.opened = this[symbols.defaults].opened;\n      }\n    }\n\n    [symbols.afterEffect](effect) {\n      if (super[symbols.afterEffect]) { super[symbols.afterEffect](effect); }\n      /** @type {any} */\n      const element = this;\n      switch (effect) {\n\n        case 'closing':\n          attributes.setClass(element, 'opened', false);\n          if (this[closeResolveKey]) {\n            const resolveClose = this[closeResolveKey];\n            this[closeResolveKey] = null;\n            resolveClose(this[closeResultKey]);\n          }\n          break;\n\n        case 'opening':\n          attributes.setClass(element, 'opened', true);\n          if (this[openResolveKey]) {\n            const resolveOpen = this[openResolveKey];\n            this[openResolveKey] = null;\n            resolveOpen();\n          }\n          break;\n      }\n    }\n\n    /**\n     * Close the component.\n     *\n     * This sets the `opened` property to true.\n     * \n     * @param {any} [result] - The result of closing the component\n     * @returns {Promise} A Promise that resolves when the close operation has\n     * completed, including any asynchronous visual effects. The result of the\n     * promise will be the object supplied to the `close` method.\n     */\n    close(result) {\n      if (super.close) { super.close(); }\n      if (this.opened) {\n        this[closeResultKey] = result;\n        this.opened = false;\n      }\n      return this[closePromiseKey];\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.opened = false;\n      return defaults;\n    }\n\n    /**\n     * True if the component is curently opened.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get opened() {\n      return this[openedKey];\n    }\n    /**\n     * @param {boolean} opened\n     */\n    set opened(opened) {\n      const parsedOpened = String(opened) === 'true';\n      const changed = parsedOpened !== this[openedKey];\n      this[openedKey] = parsedOpened;\n      if ('opened' in Base.prototype) { super.opened = parsedOpened; }\n      if (changed) {\n\n        // Set up a new promise for opposite of action we're doing.\n        if (opened) {\n          createClosePromise(this);\n        } else {\n          createOpenPromise(this);\n        }\n\n        if (this[symbols.openedChanged]) {\n          this[symbols.openedChanged](parsedOpened);\n        }\n\n        const effect = opened ? 'opening' : 'closing';\n        // Does component support async effects?\n        if (this[symbols.showEffect]) {\n          // Trigger asynchronous open/close.\n          this[symbols.showEffect](effect);\n        } else {\n          // Invoke synchronous open/close.\n          if (this[symbols.beforeEffect]) {\n            this[symbols.beforeEffect](effect);\n          }\n          this[symbols.afterEffect](effect);\n        }\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('opened-changed');\n          this.dispatchEvent(event);\n        }\n      }\n    }\n\n    /**\n     * Open the component.\n     *\n     * This sets the `opened` property to true, and returns a promise that will\n     * be invoked when a corresponding `close` method call is made. The\n     * resolution of the promise will be whatever parameter was passed to\n     * `close`.\n     * \n     * @returns {Promise} A Promise that resolves when the open operation has\n     * completed, including any asynchronous visual effects.\n     */\n    open() {\n      if (!this.opened) {\n        this.opened = true;\n      }\n      return this[openPromiseKey];\n    }\n\n    /**\n     * Toggles the component's open/opened state.\n     */\n    toggle() {\n      this.opened = !this.opened;\n    }\n\n    /**\n     * This method can be used as an alternative to listening to the\n     * \"opened-changed\" event, particularly in situations where you want to only\n     * handle the next time the component is closed.\n     * \n     * @returns {Promise} A promise that resolves when the element has\n     * completely closed, including the completion of any asynchronous opening\n     * effect.\n     */\n    whenClosed() {\n      return this[closePromiseKey];\n    }\n\n    /**\n     * This method can be used as an alternative to listening to the\n     * \"opened-changed\" event, particularly in situations where you want to only\n     * handle the next time the component is opened.\n     *\n     * @returns {Promise} A promise that resolves when the element has\n     * completely opened, including the completion of any asynchronous closing\n     * effect.\n     */\n    whenOpened() {\n      return this[openPromiseKey];\n    }\n\n  }\n\n  return OpenClose;\n}\n\n\nfunction createClosePromise(element) {\n  element[closePromiseKey] = new Promise((resolve, reject) => {\n    element[closeResolveKey] = resolve;\n  });\n}\n\nfunction createOpenPromise(element) {\n  element[openPromiseKey] = new Promise((resolve, reject) => {\n    element[openResolveKey] = resolve;\n  });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/OpenCloseMixin.js","import * as attributes from './attributes.js';\nimport deepContains from './deepContains.js';\nimport Symbol from '../mixins/Symbol.js';\nimport symbols from '../mixins/symbols.js';\n\n\n// Symbols for private data members on an element.\nconst appendedToDocumentKey = Symbol('appendedToDocument');\nconst forceAppendToBodyKey = Symbol('forceAppendToBody');\nconst placeholderKey = Symbol('placeholder');\nconst previousFocusedElementKey = Symbol('previousFocusedElement');\nconst previousZIndexKey = Symbol('previousZIndex');\n\n\n/**\n * This mixin makes an opened element appear on top of other page elements, then\n * hide or remove it when closed. This mixin and `OpenCloseMixin` form the core\n * overlay behavior for Elix components.\n * \n * The mixin expects the component to provide:\n * \n * * An invocation of `symbols.beforeEffect` and `symbols.afterEffect` methods\n *   for both \"opening\" and “closing” effects. This is generally implemented by\n *   using `OpenCloseMixin`.\n * \n * The mixin provides these features to the component:\n * \n * 1. Appends the element to the DOM when opened, if it’s not already in the\n *    DOM.\n * 2. Can calculate and apply a default z-index that in many cases will be\n *    sufficient to have the overlay appear on top of other page elements.\n * 3. Makes the element visible before any opening effects begin, and hides it\n *    after any closing effects complete.\n * 4. Remembers which element had the focus before the overlay was opened, and\n *    tries to restore the focus there when the overlay is closed.\n * 5. A `teleportToBodyOnOpen` property that optionally moves an element already\n *    in the DOM to the end of the document body when opened. This is intended\n *    only to address challenging overlay edge cases; see the discussion below.\n * \n * If the component defines the following optional members, the mixin will take\n * advantage of them:\n * \n * * An effect API compatible with `TransitionEffectMixin`. This allows an\n *   element to provide opening/closing effects. The effects are _not_ applied\n *   if the `opened` property is set in markup when the document is loading. The\n *   use of transition effects is not required. It is not necessary for a\n *   component to use `TransitionEffectMixin` or a compatible mixin. In that\n *   case, `OverlayMixin` will simply perform its work synchronously.\n * \n * All other aspects of overlay behavior are handled by other mixins and\n * wrappers. For example, addition of a backdrop element behind the overlay is\n * handled by `BackdropWrapper`. Intercepting and responding to UI events is\n * handled by `PopupModalityMixin` and `DialogModalityMixin`. Management of\n * asynchronous visual opening/closing effects are provided by\n * `TransitionEffectMixin`.\n * \n * @module OverlayMixin\n */\nexport default function OverlayMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class Overlay extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n      this.addEventListener('blur', () => {\n        // The focus was taken from us, perhaps because the focus was set\n        // elsewhere, so we don't want to try to restore focus when closing.\n        this[previousFocusedElementKey] = null;\n      });\n    }\n\n    [symbols.afterEffect](effect) {\n      if (super[symbols.afterEffect]) { super[symbols.afterEffect](effect); }\n      switch (effect) {\n        case 'closing':\n          // Hide the element.\n          makeVisible(this, false);\n\n          // Restore z-index.\n          this.style.zIndex = this[previousZIndexKey] === '' ?\n            null :\n            this[previousZIndexKey];\n          this[previousZIndexKey] = null;\n\n          if (this[appendedToDocumentKey]) {\n            // The overlay wasn't in the document when opened, so we added it.\n            // Remove it now.\n            this.parentNode.removeChild(this);\n            this[appendedToDocumentKey] = false;\n          } else if (this[placeholderKey]) {\n            // The overlay was moved; return it to its original location.\n            this[placeholderKey].parentNode.replaceChild(this, this[placeholderKey]);\n            this[placeholderKey] = null;\n          }\n\n          break;\n      }\n    }\n\n    [symbols.beforeEffect](effect) {\n      if (super[symbols.beforeEffect]) { super[symbols.beforeEffect](effect); }\n      switch (effect) {\n\n        case 'closing':\n          // Restore previously focused element before closing.\n          if (this[previousFocusedElementKey]) {\n            this[previousFocusedElementKey].focus();\n            this[previousFocusedElementKey] = null;\n          }\n          break;\n\n        case 'opening':\n          // Remember which element had the focus before we opened.\n          this[previousFocusedElementKey] = document.activeElement;\n\n          // Add the element to the document if it's not present yet.\n          /** @type {any} */\n          const element = this;\n          const isElementInBody = deepContains(document.body, element);\n          if (isElementInBody) {\n            if (this.teleportToBodyOnOpen) {\n              // Swap a placeholder for the overlay and move the overlay to the\n              // top level of the document body.\n              this[placeholderKey] = createPlaceholder(this);\n              this.parentNode.replaceChild(this[placeholderKey], this);\n              document.body.appendChild(element);\n            }\n          } else {\n            // Overlay isn't in document yet.\n            this[appendedToDocumentKey] = true;\n            document.body.appendChild(element);\n          }\n\n          // Remember the element's current z-index.\n          this[previousZIndexKey] = this.style.zIndex;\n          // It seems like it should be possible to rely on inspecting zIndex\n          // via getComputedStyle. However, unit testing reveals at least one\n          // case where an inline zIndex style change made immediately before\n          // opening the overlay was not reflected by getComputedStyle. Hence,\n          // we also check the inline style value.\n          // Also note that Safari returns a default zIndex of \"0\" for elements\n          // with position: fixed, while Blink returns \"auto\".\n          const style = getComputedStyle(element)\n          const computedZIndex = style.zIndex;\n          if (element.style.zIndex === ''\n              && (computedZIndex === 'auto' ||\n                (style.position === 'fixed' && computedZIndex === '0'))) {\n            // Assign default z-index.\n            this.style.zIndex = maxZIndexInUse() + 1;\n          }\n\n          // Finally make it visible and give it focus.\n          makeVisible(this, true);\n          this.focus();\n          break;\n\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      /** @type {any} */\n      const element = this;\n      attributes.writePendingAttributes(element);\n      this.setAttribute('tabindex', '0');\n    }\n\n    /**\n     * True if the overlay should be moved from its existing place in the DOM to\n     * the end of the document body when the overlay is opened, then returned to\n     * its original location when closed. This property exists to address a\n     * small number of challenging overlay edge cases, and should generally be\n     * left false.\n     * \n     * @type {boolean}\n     * @default false\n     */\n    get teleportToBodyOnOpen() {\n      return this[forceAppendToBodyKey];\n    }\n    /**\n     * @param {boolean} teleportToBodyOnOpen\n     */\n    set teleportToBodyOnOpen(teleportToBodyOnOpen) {\n      const parsed = String(teleportToBodyOnOpen) === 'true';\n      this[forceAppendToBodyKey] = parsed;\n      if ('teleportToBodyOnOpen' in Base.prototype) { super.opened = parsed; }\n      /** @type {any} */\n      const element = this;\n      attributes.setAttribute(element, 'teleport-to-body-on-open', parsed);\n    }\n  }\n\n  return Overlay;\n\n}\n\n\n/*\n * Return a placeholder element used to hold an overlay's position in the DOM if\n * it is using teleportToBodyOnOpen, so that we can return the overlay to its\n * original location when it's closed.\n */\nfunction createPlaceholder(element) {\n  const message = ` Placeholder for the open ${element.localName}, which will return here when closed. `;\n  const placeholder = document.createComment(message);\n  return placeholder;\n}\n\n\nfunction makeVisible(element, visible) {\n  attributes.setClass(element, 'visible', visible);\n}\n\n\n/*\n * Return the highest z-index currently in use in the document's light DOM.\n * \n * This calculation looks at all light DOM elements, so is theoretically\n * expensive. That said, it only runs when an overlay is opening, and is only used\n * if an overlay doesn't have a z-index already. In cases where performance is\n * an issue, this calculation can be completely circumvented by manually\n * applying a z-index to an overlay.\n */\nfunction maxZIndexInUse() {\n  const elements = document.body.querySelectorAll('*');\n  const zIndices = Array.prototype.map.call(elements, element => {\n    const style = getComputedStyle(element);\n    let zIndex = 0;\n    if (style.position !== 'static' && style.zIndex !== 'auto') {\n      const parsed = style.zIndex ? parseInt(style.zIndex) : 0;\n      zIndex = !isNaN(parsed) ? parsed : 0;\n    }\n    return zIndex;\n  });\n  return Math.max(...zIndices);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/OverlayMixin.js","import deepContains from './deepContains.js';\nimport symbols from './symbols.js';\n\n\n/**\n * Mixin which maps a click (actually, a mousedown) to an item selection.\n *\n * This simple mixin is useful in list-like elements like [ListBox](ListBox),\n * where a click on a list item implicitly selects it.\n *\n * The standard use for this mixin is in list-like elements. Native list\n * boxes don't appear to be consistent with regard to whether they select\n * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n * On touch devices, that event appears to trigger when the touch is *released*.\n *\n * This mixin only listens to mousedown events for the primary mouse button\n * (typically the left button). Right-clicks are ignored so that the browser\n * may display a context menu.\n *\n * Much has been written about how to ensure \"fast tap\" behavior on mobile\n * devices. This mixin makes a very straightforward use of a standard event, and\n * this appears to perform well on mobile devices when, e.g., the viewport is\n * configured with `width=device-width`.\n *\n * This mixin expects the component to provide an `items` property. It also\n * expects the component to define a `selectedItem` property; you can provide\n * that yourself, or use [SingleSelectionMixin](SingleSelectionMixin).\n *\n * If the component receives a clicks that doesn't correspond to an item (e.g.,\n * the user clicks on the element background visible between items), the\n * selection will be removed. However, if the component sets `selectionRequired`\n * to true, a background click will *not* remove the selection.\n *\n * @module ClickSelectionMixin\n */\nexport default function ClickSelectionMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class ClickSelection extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n      this.addEventListener('mousedown', event => {\n\n        // Only process events for the main (usually left) button.\n        if (event.button !== 0) {\n          return;\n        }\n\n        this[symbols.raiseChangeEvents] = true;\n\n        // In some situations, the event target will not be the child which was\n        // originally clicked on. E.g.,  If the item clicked on is a button, the\n        // event seems to be raised in phase 2 (AT_TARGET) — but the event\n        // target will be the component, not the item that was clicked on.\n        // Instead of using the event target, we get the first node in the\n        // event's composed path.\n        // @ts-ignore\n        const target = event.composedPath()[0];\n\n        // Find which item was clicked on and, if found, select it. For elements\n        // which don't require a selection, a background click will determine\n        // the item was null, in which we case we'll remove the selection.\n        const item = itemForTarget(this, target);\n        if (item || !this.selectionRequired) {\n\n          if (!('selectedItem' in this)) {\n            console.warn(`ClickSelectionMixin expects a component to define a \"selectedItem\" property.`);\n          } else {\n            this.selectedItem = item;\n          }\n\n          // We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n  }\n\n  return ClickSelection;\n}\n\n\n/**\n * Return the list item that is, or contains, the indicated target node.\n * Return null if not found.\n *\n * This is sufficiently flexible to accommodate the possibility of the target\n * being inside arbitrarily deep layers of shadow DOM containment.\n */\nfunction itemForTarget(element, target) {\n  const items = element.items;\n  for (const index in element.items) {\n    const item = items[index];\n    if (deepContains(item, target)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/ClickSelectionMixin.js","import Symbol from './Symbol.js';\nimport symbols from './symbols.js';\n\n\n// Symbols for private data members on an element.\nconst slotchangeFiredKey = Symbol('slotchangeFired');\n\n\n/**\n * Mixin which defines a component's `symbols.content` property as the flattened\n * set of nodes assigned to its default slot.\n *\n * This also provides notification of changes to a component's content. It\n * will invoke a `symbols.contentChanged` method when the component is first\n * instantiated, and whenever its distributed children change. This is intended\n * to satisfy the Gold Standard checklist item for monitoring\n * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n *\n * Example:\n *\n * ```\n * class CountingElement extends DefaultSlotContentMixin(HTMLElement) {\n *\n *   constructor() {\n *     super();\n *     let root = this.attachShadow({ mode: 'open' });\n *     root.innerHTML = `<slot></slot>`;\n *     this[symbols.shadowCreated]();\n *   }\n *\n *   [symbols.contentChanged]() {\n *     if (super[symbols.contentChanged]) { super[symbols.contentChanged](); }\n *     // Count the component's children, both initially and when changed.\n *     this.count = this.distributedChildren.length;\n *   }\n *\n * }\n * ```\n *\n * To use this mixin, the component should define a default (unnamed) `slot`\n * element in its shadow subtree.\n *\n * To receive `contentChanged` notification, this mixin expects a component to\n * invoke a method called `symbols.shadowCreated` after the component's shadow\n * root has been created and populated.\n *\n * Most Elix [elements](elements) use `DefaultSlotContentMixin`, including\n * [ListBox](ListBox), [Modes](Modes), and [Tabs](Tabs).\n *\n * @module DefaultSlotContentMixin\n */\nexport default function DefaultSlotContentMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class DefaultSlotContent extends Base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // HACK for Blink, which doesn't correctly fire initial slotchange.\n      // See https://bugs.chromium.org/p/chromium/issues/detail?id=696659\n      setTimeout(() => {\n        // By this point, the slotchange event should have fired.\n        if (!this[slotchangeFiredKey]) {\n          // slotchange event didn't fire; we're in Blink. Force the invocation\n          // of contentChanged that would have happened on slotchange.\n          if (this[symbols.contentChanged]) {\n            this[symbols.contentChanged]();\n          }\n        }\n      });\n    }\n\n    /**\n     * The content of this component, defined to be the flattened set of\n     * nodes assigned to its default unnamed slot.\n     *\n     * @type {Element[]}\n     */\n    get [symbols.content]() {\n      const slot = defaultSlot(this);\n      let assignedNodes;\n      // As of 18 July 2017, the polyfill contains a bug\n      // (https://github.com/webcomponents/shadydom/issues/165)\n      // that throws an exception if assignedNodes is read during a constructor\n      // Until that bug is fixed, we work around the problem by catching the\n      // exception.\n      try {\n        assignedNodes = slot ?\n          slot.assignedNodes({ flatten: true }) :\n          [];\n      } catch (e) {\n        assignedNodes = [];\n      }\n      return assignedNodes;\n    }\n\n    [symbols.shadowCreated]() {\n      if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n      // Listen to changes on the default slot.\n      const slot = defaultSlot(this);\n      if (slot) {\n        slot.addEventListener('slotchange', event => {\n          this[slotchangeFiredKey] = true;\n          if (this[symbols.contentChanged]) {\n            this[symbols.contentChanged]();\n          }\n        });\n      }\n    }\n  }\n\n  return DefaultSlotContent;\n}\n\n\nfunction defaultSlot(element) {\n  const defaultSlot = element.shadowRoot && element.shadowRoot.querySelector('slot:not([name])');\n  if (element.shadowRoot && !defaultSlot) {\n    console.warn(`DefaultSlotContentMixin expects a component to define a shadow tree that includes a default (unnamed) slot.`);\n  }\n  return defaultSlot;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/DefaultSlotContentMixin.js","import { toggleClass } from './attributes.js';\n\n\n//\n// Global state shared by all elements using this mixin.\n//\n\n// We assume that the keyboard changed the focus unless we have proof otherwise.\nlet focusedWithKeyboard = true;\n\n// Flag used to track keyboard focus state across window blur/focus events.\nlet previousFocusedWithKeyboard = false;\n\nlet listeningToWindowFocus = false;\n\n\n/**\n * Adds a `focus-ring` class to the element when (and only when) it receives\n * focus via the keyboard. This is useful for buttons and other components that\n * don't generally show a focus ring for mouse/touch interaction.\n *\n * The following demo shows button that display a focus ring only when\n * you move the focus onto them via the keyboard, and not with the mouse or touch.\n *\n * [Button components using FocusRingMixin](/demos/focusRing.html)\n *\n * This is inspired by work on the `:focus-ring` pseudo-selector.\n * See https://github.com/wicg/focus-ring for details.\n *\n * This mixin manages a `focus-ring` class on an element that be used to\n * suppress the default focus ring unless the keyboard was used. The element's\n * stylesheet should include a CSS rule of the form:\n *\n *     :host(:focus:not(.focus-ring)) {\n *       outline: none;\n *     }\n *\n * @module FocusRingMixin\n */\nexport default function FocusRingMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class FocusRing extends Base {\n    constructor() {\n      // @ts-ignore\n      super();\n\n      // We only want to start listening to window focus events if an element\n      // using this mixin is actually instantiated, and we only do that for the\n      // first such element. All elements can share that window focus listeners.\n      if (!listeningToWindowFocus) {\n        window.addEventListener('focus', windowFocused);\n\n        // Firefox does not appear to listen to focus events on the window.\n        // We listen to focus events on the document instead. There does not\n        // appear to be a browser that listens to focus on both window and\n        // document, so wiring up focus listeners to both seems to be safe.\n        document.addEventListener('focus', windowFocused);\n\n        listeningToWindowFocus = true;\n      }\n\n      this.addEventListener('focus', event => {\n        /** @type {any} */\n        const element = this;\n        toggleClass(element, 'focus-ring', focusedWithKeyboard);\n\n        // Remember how focus changed in case window loses focus.\n        previousFocusedWithKeyboard = focusedWithKeyboard;\n\n        // Go back to assuming use of the keyboard.\n        focusedWithKeyboard = true;\n      });\n\n      this.addEventListener('mousedown', event => {\n        // If this element receives focus, it won't be because of the keyboard.\n        focusedWithKeyboard = false;\n      });\n\n      this.addEventListener('blur', event => {\n        this.classList.remove('focus-ring');\n      });\n    }\n  }\n\n  return FocusRing;\n}\n\n\n// The window has regained focus after having lost it. If the last\n// element that had the focus obtained the focus via the keyboard,\n// set our keyboard input flag. That previously-focused element is\n// about to receive a focus event, and the handler for that can then\n// treat the situation as if the focus was obtained via the keyboard.\n// That helps a keyboard user reacquire the focused element when\n// returning to the window.\nfunction windowFocused() {\n  focusedWithKeyboard = previousFocusedWithKeyboard;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/FocusRingMixin.js","import symbols from './symbols.js';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/**\n * Mixin which treats the selected item in a list as the active item in ARIA\n * accessibility terms.\n *\n * Handling ARIA selection state properly is actually quite complex:\n *\n * * The items in the list need to be indicated as possible items via an ARIA\n *   `role` attribute value such as \"option\".\n * * The selected item need to be marked as selected by setting the item's\n *   `aria-selected` attribute to true *and* the other items need be marked as\n *   *not* selected by setting `aria-selected` to false.\n * * The outermost element with the keyboard focus needs to have attributes\n *   set on it so that the selection is knowable at the list level via the\n *   `aria-activedescendant` attribute.\n * * Use of `aria-activedescendant` in turn requires that all items in the\n *   list have ID attributes assigned to them.\n *\n * This mixin tries to address all of the above requirements. To that end,\n * this mixin will assign generated IDs to any item that doesn't already have\n * an ID.\n *\n * ARIA relies on elements to provide `role` attributes. This mixin will apply\n * a default role of \"listbox\" on the outer list if it doesn't already have an\n * explicit role. Similarly, this mixin will apply a default role of \"option\"\n * to any list item that does not already have a role specified.\n *\n * This mixin expects a set of members that manage the state of the selection:\n * `[symbols.itemSelected]`, `[symbols.itemAdded]`, and `selectedItem`. You can\n * supply these yourself, or do so via\n * [SingleSelectionMixin](SingleSelectionMixin).\n *\n * @module\n */\nexport default function(Base) {\n\n  // The class prototype added by the mixin.\n  class SelectionAria extends Base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the overall component.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      defaults.itemRole = 'option';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role for an individual item.\n        item.setAttribute('role', this[symbols.defaults].itemRole);\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in Base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAria;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/SelectionAriaMixin.js","import AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\nimport BackdropWrapper from './BackdropWrapper.js';\nimport FocusCaptureWrapper from './FocusCaptureWrapper.js';\nimport DialogModalityMixin from '../mixins/DialogModalityMixin.js';\nimport KeyboardMixin from '../mixins/KeyboardMixin.js';\nimport OpenCloseMixin from '../mixins/OpenCloseMixin.js';\nimport OverlayMixin from '../mixins/OverlayMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport symbols from '../mixins/symbols.js';\n\n\nconst Base =\n  // Relative order of wrapper application matters: first focus capture\n  // wrapper, then backdrop wrapper. Remaining mixins can be applied in\n  // any order.\n  BackdropWrapper(\n  FocusCaptureWrapper(\n\n  AttributeMarshallingMixin(\n  DialogModalityMixin(\n  KeyboardMixin(\n  OpenCloseMixin(\n  OverlayMixin(\n  ShadowTemplateMixin(\n    HTMLElement\n  ))))))));\n\n\n/**\n * This component presents its children as a basic modal dialog which appears on\n * top of the main page content and which the user must interact with before\n * they can return to the page.\n * \n * Dialog uses `BackdropWrapper` to add a backdrop behind the main overlay\n * content. Both the backdrop and the dialog itself can be styled.\n * \n * @extends {HTMLElement}\n * @mixes AttributeMarshallingMixin\n * @mixes BackdropWrapper\n * @mixes DialogModalityMixin\n * @mixes FocusCaptureWrapper\n * @mixes KeyboardMixin\n * @mixes OpenCloseMixin\n * @mixes OverlayMixin\n * @mixes ShadowTemplateMixin\n */\nclass Dialog extends Base {\n\n  [symbols.template](filler) {\n    return super[symbols.template](`\n      <style>\n        :host {\n          align-items: center;\n          display: flex;\n          flex-direction: column;\n          justify-content: center;\n        }\n\n        :host(:not(.visible)) {\n          display: none;\n        }\n\n        #backdrop {\n          background: black;\n          opacity: 0.2;\n        }\n\n        #overlayContent {\n          background: white;\n          border: 1px solid rgba(0, 0, 0, 0.2);\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);\n        }\n      </style>\n      ${filler || `<slot></slot>`}\n    `);\n  }\n\n}\n\n\ncustomElements.define('elix-dialog', Dialog);\nexport default Dialog;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/Dialog.js","import AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\nimport ContentItemsMixin from '../mixins/ContentItemsMixin.js';\nimport DefaultSlotContentMixin from '../mixins/DefaultSlotContentMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport SingleSelectionMixin from '../mixins/SingleSelectionMixin.js';\nimport symbols from '../mixins/symbols.js';\n\n\nconst Base =\n  AttributeMarshallingMixin(\n  ContentItemsMixin(\n  DefaultSlotContentMixin(\n  ShadowTemplateMixin(\n  SingleSelectionMixin(\n    HTMLElement\n  )))));\n\n/**\n * Shows exactly one child element at a time. This can be useful, for example,\n * if a given UI element has multiple modes that present substantially different\n * elements.\n *\n * This component doesn't provide any UI for changing which mode is shown. A\n * common pattern in which buttons select the mode are tabs, a pattern\n * implemented by the [Tabs](Tabs) component.\n *\n * @extends HTMLElement\n * @mixes AttributeMarshallingMixin\n * @mixes ContentItemsMixin\n * @mixes DefaultSlotContentMixin\n * @mixes ShadowTemplateMixin\n * @mixes SingleSelectionMixin\n */\nclass Modes extends Base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  [symbols.itemAdded](item) {\n    if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    // TODO: See node about aria-hidden below.\n    // item.setAttribute('aria-hidden', 'false');\n  }\n\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.style.display = selected ? '' : 'none';\n    // TODO: Should the modes which are not visible be exposed to ARIA?\n    // Sometimes this will be desirable, as when an inactive mode should be\n    // both physically invisible and invisible to ARIA. In other cases, it\n    // might be desirable to let the user navigate the modes with the keyboard,\n    // in which case ARIA should be able to see the inactive modes.\n    // item.setAttribute('aria-hidden', !selected);\n  }\n\n  [symbols.template](filler) {\n    return `\n      <style>\n        :host {\n          display: inline-block;\n        }\n      </style>\n      ${filler || `<slot></slot>`}\n    `;\n  }\n\n}\n\n\ncustomElements.define('elix-modes', Modes);\nexport default Modes;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/Modes.js","import defaultScrollTarget from './defaultScrollTarget.js';\nimport symbols from './symbols.js';\n\n\n/**\n * Mixin which maps page keys (Page Up, Page Down) into operations that move\n * the selection by one page.\n *\n * The keyboard interaction model generally follows that of Microsoft Windows'\n * list boxes instead of those in OS X:\n *\n * * The Page Up/Down and Home/End keys actually change the selection, rather\n *   than just scrolling. The former behavior seems more generally useful for\n *   keyboard users.\n *\n * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n *   visible item if the selection is not already there. Thereafter, the key\n *   will move the selection up/down by a page, and (per the above point) make\n *   the selected item visible.\n *\n * To ensure the selected item is in view following use of Page Up/Down, use\n * the related [SelectionInViewMixin](SelectionInViewMixin).\n *\n * This mixin expects the component to provide:\n *\n * * A `[symbols.keydown]` method invoked when a key is pressed. You can use\n *   [KeyboardMixin](KeyboardMixin) for that purpose, or wire up your own\n *   keyboard handling and call `[symbols.keydown]` yourself.\n * * A `selectedIndex` property that indicates the index of the selected item.\n *\n * @module KeyboardPagedSelectionMixin\n */\nexport default function KeyboardPagedSelectionMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class KeyboardPagedSelection extends Base {\n\n    [symbols.keydown](event) {\n      let handled = false;\n      const orientation = this[symbols.orientation];\n      if (orientation !== 'horizontal') {\n        switch (event.keyCode) {\n          case 33: // Page Up\n          handled = this.pageUp();\n          break;\n          case 34: // Page Down\n          handled = this.pageDown();\n          break;\n        }\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) { super.pageDown(); }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) { super.pageUp(); }\n      return scrollOnePage(this, false);\n    }\n\n    /* Provide a default scrollTarget implementation if none exists. */\n    get [symbols.scrollTarget]() {\n      /** @type {any} */\n      const element = this;\n      return super[symbols.scrollTarget] || defaultScrollTarget(element);\n    }\n\n  }\n\n  return KeyboardPagedSelection;\n}\n\n\n/**\n * Return the item whose content spans the given y position (relative to the\n * top of the list's scrolling client area), or null if not found.\n * \n * If downward is true, move down the list of items to find the first item\n * found at the given y position; if downward is false, move up the list of\n * \n * items to find the last item at that position.\n */\nfunction getIndexOfItemAtY(element, scrollTarget, y, downward) {\n\n  const items = element.items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n\n  const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\n  // Find the item spanning the indicated y coordinate.\n  let item;\n  let itemIndex = start;\n  let itemTop;\n  let found = false;\n  while (itemIndex !== end) {\n    item = items[itemIndex];\n    itemTop = item.offsetTop - topOfClientArea;\n    const itemBottom = itemTop + item.offsetHeight;\n    if (itemTop <= y && itemBottom >= y) {\n      // Item spans the indicated y coordinate.\n      found = true;\n      break;\n    }\n    itemIndex += step;\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = itemStyle.paddingTop ? parseFloat(itemStyle.paddingTop) : 0;\n  const itemPaddingBottom = itemStyle.paddingBottom ? parseFloat(itemStyle.paddingBottom) : 0;\n  const contentTop = itemTop + item.clientTop + itemPaddingTop;\n  const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n    // The indicated coordinate hits the actual item content.\n    return itemIndex;\n  }\n  else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return itemIndex - step;\n  }\n}\n\n/**\n * Move by one page downward (if downward is true), or upward (if false).\n * Return true if we ended up changing the selection, false if not.\n */\nfunction scrollOnePage(element, downward) {\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll select that item if it's not already selected.\n  const scrollTarget = element[symbols.scrollTarget];\n  const edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, scrollTarget, edge, downward);\n\n  const selectedIndex = element.selectedIndex;\n\n  let newIndex;\n  \n  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n    // The item at the edge was already selected, so scroll in the indicated\n    // direction by one page. Leave the new item at that edge selected.\n    const delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n    newIndex = getIndexOfItemAtY(element, scrollTarget, edge + delta, downward);\n  }\n  else {\n    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n    // just select that item. That is, the first attempt to page up/down\n    // usually just moves the selection to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We can't find an item in the direction we want to travel. Select the\n    // last item (if moving downward) or first item (if moving upward).\n    newIndex = (downward ? element.items.length - 1 : 0);\n  }\n\n  if (newIndex !== selectedIndex) {\n    element.selectedIndex = newIndex;\n    return true; // We handled the page up/down ourselves.\n  }\n  else {\n    return false; // We didn't do anything.\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/KeyboardPagedSelectionMixin.js","import constants from './constants.js';\nimport Symbol from './Symbol.js';\nimport symbols from './symbols.js';\n\n\n// Symbols for private data members on an element.\nconst itemTextContentsKey = Symbol('itemTextContents');\nconst typedPrefixKey = Symbol('typedPrefix');\nconst prefixTimeoutKey = Symbol('prefixTimeout');\nconst settingSelectionKey = Symbol('settingSelection');\n\n\n/**\n * Mixin that handles list box-style prefix typing, in which the user can type\n * a string to select the first item that begins with that string.\n *\n * Example: suppose a component using this mixin has the following items:\n *\n *     <sample-list-component>\n *       <div>Apple</div>\n *       <div>Apricot</div>\n *       <div>Banana</div>\n *       <div>Blackberry</div>\n *       <div>Blueberry</div>\n *       <div>Cantaloupe</div>\n *       <div>Cherry</div>\n *       <div>Lemon</div>\n *       <div>Lime</div>\n *     </sample-list-component>\n *\n * If this component receives the focus, and the user presses the \"b\" or \"B\"\n * key, the \"Banana\" item will be selected, because it's the first item that\n * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n * \"Blackberry\" will be selected.\n *\n * The prefix typing feature has a one second timeout — the prefix to match\n * will be reset after a second has passed since the user last typed a key.\n * If, in the above example, the user waits a second between typing \"b\" and\n * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin) for that\n * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin also expects the component to provide an `items` property. The\n * `textContent` of those items will be used for purposes of prefix matching.\n *\n * @module KeyboardPrefixSelectionMixin\n */\nexport default function KeyboardPrefixSelectionMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class KeyboardPrefixSelection extends Base {\n\n    // Default implementation returns an item's `alt` attribute or its\n    // `textContent`, in that order.\n    [symbols.getItemText](item) {\n      return item.getAttribute('alt') || item.textContent;\n    }\n\n    // If the set of items has changed, reset the prefix. We'll also need to\n    // rebuild our cache of item text the next time we're asked for it.\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n      this[itemTextContentsKey] = null;\n      resetTypedPrefix(this);\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n      let resetPrefix = true;\n\n      switch (event.keyCode) {\n        case 8: // Backspace\n          handleBackspace(this);\n          handled = true;\n          resetPrefix = false;\n          break;\n        case 27: // Escape\n          handled = true;\n          break;\n        default:\n          if (!event.ctrlKey && !event.metaKey && !event.altKey &&\n              event.which !== 32 /* Space */) {\n            handlePlainCharacter(this, String.fromCharCode(event.keyCode));\n          }\n          resetPrefix = false;\n      }\n\n      if (resetPrefix) {\n        resetTypedPrefix(this);\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in Base.prototype) { super.selectedIndex = index; }\n      if (!this[settingSelectionKey]) {\n        // Someone else (not this mixin) has changed the selection. In response,\n        // we invalidate the prefix under construction.\n        resetTypedPrefix(this);\n      }\n    }\n\n    /**\n     * Select the first item whose text content begins with the given prefix.\n     *\n     * @param {string} prefix - The prefix string to search for\n     * @returns {boolean}\n     */\n    selectItemWithTextPrefix(prefix) {\n      if (super.selectItemWithTextPrefix) { super.selectItemWithTextPrefix(prefix); }\n      if (prefix == null || prefix.length === 0) {\n        return false;\n      }\n      const index = getIndexOfItemWithTextPrefix(this, prefix);\n      if (index >= 0) {\n        // Update the selection. During that operation, set the flag that lets\n        // us know that we are the cause of the selection change. See note at\n        // this mixin's `selectedIndex` implementation.\n        this[settingSelectionKey] = true;\n        this.selectedIndex = index;\n        this[settingSelectionKey] = false;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n  }\n\n  return KeyboardPrefixSelection;\n}\n\n\n// Return the index of the first item with the given prefix, else -1.\nfunction getIndexOfItemWithTextPrefix(element, prefix) {\n  const itemTextContents = getItemTextContents(element);\n  const prefixLength = prefix.length;\n  for (let i = 0; i < itemTextContents.length; i++) {\n    const itemTextContent = itemTextContents[i];\n    if (itemTextContent.substr(0, prefixLength) === prefix) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Return an array of the text content (in lowercase) of all items.\n// Cache these results.\nfunction getItemTextContents(element) {\n  if (!element[itemTextContentsKey]) {\n    const items = element.items;\n    element[itemTextContentsKey] = Array.prototype.map.call(items, item => {\n      const text = element[symbols.getItemText](item);\n      return text.toLowerCase();\n    });\n  }\n  return element[itemTextContentsKey];\n}\n\n// Handle the Backspace key: remove the last character from the prefix.\nfunction handleBackspace(element) {\n  const length = element[typedPrefixKey] ? element[typedPrefixKey].length : 0;\n  if (length > 0) {\n    element[typedPrefixKey] = element[typedPrefixKey].substr(0, length - 1);\n  }\n  element.selectItemWithTextPrefix(element[typedPrefixKey]);\n  setPrefixTimeout(element);\n}\n\n// Add a plain character to the prefix.\nfunction handlePlainCharacter(element, char) {\n  const prefix = element[typedPrefixKey] || '';\n  element[typedPrefixKey] = prefix + char.toLowerCase();\n  element.selectItemWithTextPrefix(element[typedPrefixKey]);\n  setPrefixTimeout(element);\n}\n\n// Stop listening for typing.\nfunction resetPrefixTimeout(element) {\n  if (element[prefixTimeoutKey]) {\n    clearTimeout(element[prefixTimeoutKey]);\n    element[prefixTimeoutKey] = false;\n  }\n}\n\n// Clear the prefix under construction.\nfunction resetTypedPrefix(element) {\n  element[typedPrefixKey] = '';\n  resetPrefixTimeout(element);\n}\n\n// Wait for the user to stop typing.\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  element[prefixTimeoutKey] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, constants.TYPING_TIMEOUT_DURATION);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/KeyboardPrefixSelectionMixin.js","import defaultScrollTarget from './defaultScrollTarget.js';\nimport symbols from './symbols.js';\n\n\n/**\n * Mixin which scrolls a container horizontally and/or vertically to ensure that\n * a newly-selected item is visible to the user.\n *\n * When the selected item in a list-like component changes, the selected item\n * should be brought into view so that the user can confirm their selection.\n *\n * This mixin expects a `selectedItem` property to be set when the selection\n * changes. You can supply that yourself, or use\n * [SingleSelectionMixin](SingleSelectionMixin).\n *\n * @module SelectionInViewMixin\n */\nexport default function (Base) {\n\n  // The class prototype added by the mixin.\n  class SelectionInView extends Base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      const selectedItem = this.selectedItem;\n      if (selectedItem) {\n        this.scrollItemIntoView(selectedItem);\n      }\n    }\n\n    /**\n     * Scroll the given element completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * This scrolls the containing element defined by the `scrollTarget`\n     * property. See that property for a discussion of the default value of\n     * that property.\n     *\n     * @param {Element} item - the item to scroll into view.\n     */\n    scrollItemIntoView(item) {\n      if (super.scrollItemIntoView) { super.scrollItemIntoView(); }\n\n      const scrollTarget = this[symbols.scrollTarget];\n\n      // Determine the bounds of the scroll target and item. We use\n      // getBoundingClientRect instead of .offsetTop, etc., because the latter\n      // round values, and we want to handle fractional values.\n      const scrollTargetRect = scrollTarget.getBoundingClientRect();\n      const itemRect = item.getBoundingClientRect();\n\n      // Determine how far the item is outside the viewport.\n      const bottomDelta = itemRect.bottom - scrollTargetRect.bottom;\n      const topDelta = itemRect.top - scrollTargetRect.top;\n      const leftDelta = itemRect.left - scrollTargetRect.left;\n      const rightDelta = itemRect.right - scrollTargetRect.right;\n\n      // Scroll the target as necessary to bring the item into view.\n      if (bottomDelta > 0) {\n        scrollTarget.scrollTop += bottomDelta;            // Scroll down\n      } else if (topDelta < 0) {\n        scrollTarget.scrollTop += Math.ceil(topDelta);    // Scroll up\n      }\n      if (rightDelta > 0) {\n        scrollTarget.scrollLeft += rightDelta;            // Scroll right\n      } else if (leftDelta < 0) {\n        scrollTarget.scrollLeft += Math.ceil(leftDelta);  // Scroll left\n      }\n    }\n\n    /* Provide a default scrollTarget implementation if none exists. */\n    get [symbols.scrollTarget]() {\n      /** @type {any} */\n      const element = this;\n      return super[symbols.scrollTarget] || defaultScrollTarget(element);\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in Base.prototype) { super.selectedItem = item; }\n      if (item) {\n        // Keep the selected item in view.\n        this.scrollItemIntoView(item);\n      }\n    }\n  }\n\n  return SelectionInView;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/SelectionInViewMixin.js","import Symbol from './Symbol.js';\nimport symbols from '../mixins/symbols.js';\nimport * as utilities from './utilities.js';\n\n\n// Symbols for private data members on an element.\nconst enableEffectsKey = Symbol('enableEffects');\nconst transitionendListenerKey = Symbol('transitionendListener');\n\n\n/**\n * This mixin enables asynchronous visual effects by applying CSS classes that\n * can trigger CSS transitions. It provides a standard timing model so that work\n * can be performed both before and after the asynchronous effects run.\n * \n * Thix mixin expects the component to provide:\n * \n * * Styling with CSS transitions triggered by the application of CSS classes.\n * \n * The mixin provides these features to the component:\n * \n * * A `symbols.showEffect` method that invokes the following methods on the\n *   component in order: `symbols.beforeEffect`, `symbols.applyEffect`, and\n *   `symbols.afterEffect`.\n * * A `symbols.applyEffect` method implementation that applies CSS classes to\n *   the component host to trigger the start of the CSS transition.\n * * Suppresses effect application if requested before an element’s\n *   connectedCallback is invoked.\n * * Suppresses effects if the user has expressed an accessibility preference\n *   for reduced motion. See\n *   https://webkit.org/blog/7551/responsive-design-for-motion/.\n * \n * If the component defines the following optional members, the mixin will take\n * advantage of them:\n * \n * * `symbols.beforeEffect` method which runs synchronously before applyEffect\n *   is invoked.\n * * `symbols.afterEffect` method which runs synchronously after applyEffect has\n *   completed.\n * * `symbols.elementsWithTransitions` method that returns an array of elements\n *   that will be affected by the transitions.\n * \n * The timing model imposed by `TransitionEffectMixin` is designed to be\n * replicated in other mixins. For example, Elix expects to eventually create a\n * mixin to trigger effects that use the Web Animations API. That mixin will use\n * the same timing model so that it could be used as a drop-in replacement for\n * `TransitionEffectMixin`.\n * \n * @module TransitionEffectMixin\n */\nexport default function TransitionEffectMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class TransitionEffect extends Base {\n\n    [symbols.afterEffect](effect) {\n      if (super[symbols.afterEffect]) { super[symbols.afterEffect](effect); }\n      this.classList.remove(effect);\n      this.classList.remove('effect');\n      if (this instanceof HTMLElement) {\n        utilities.webkitForceStyleUpdate(this);\n      }\n      if (this[transitionendListenerKey]) {\n        getTransitionElements(this, effect).forEach(element => {\n          element.removeEventListener('transitionend', this[transitionendListenerKey]);\n        });\n        this[transitionendListenerKey] = null;\n      }\n    }\n\n    [symbols.applyEffect](effect) {\n      const base = super.applyEffect ? super[symbols.applyEffect](effect) : Promise.resolve();\n\n      const animationEndPromise = new Promise((resolve, reject) => {\n        // Set up to handle a transitionend event once.\n        // The handler will be removed when the promise resolves.\n        this[transitionendListenerKey] = (event) => {\n          event.stopPropagation();\n          resolve();\n        };\n      });\n\n      const animationStartPromise = new Promise((resolve, reject) => {\n        // Apply the effect.\n        requestAnimationFrame(() => {\n\n          getTransitionElements(this, effect).forEach(element => {\n            element.addEventListener('transitionend', this[transitionendListenerKey]);\n          });\n          \n          this.classList.add(effect);\n          this.classList.add('effect');\n          if (this instanceof HTMLElement) {\n            utilities.webkitForceStyleUpdate(this);\n          }\n          resolve();\n        });\n      });\n\n      return base\n      .then(() => animationStartPromise)\n      .then(() => animationEndPromise);\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Allow async effects.\n      this[enableEffectsKey] = true;\n    }\n\n    [symbols.showEffect](effect) {\n\n      if (super[symbols.effect]) { super[symbols.effect](effect); }\n\n      // Tell any effect currently in progress to finish / clean up.\n      if (this[symbols.currentEffect]) {\n        this[symbols.afterEffect](this[symbols.currentEffect]);\n      }\n\n      this[symbols.currentEffect] = effect;\n\n      // Before\n      if (this[symbols.beforeEffect]) {\n        this[symbols.beforeEffect](effect);\n      }\n\n      // Don't show effects if user has set accessibility preference for reduced\n      // motion.\n      const prefersReducedMotion = matchMedia('(prefers-reduced-motion)').matches;\n\n      // Apply\n      let applyPromise;\n      if (!this[enableEffectsKey] || prefersReducedMotion) {\n        applyPromise = Promise.resolve();\n      } else {\n        applyPromise = this[symbols.applyEffect](effect);\n      }\n\n      return applyPromise\n      .then(() => {\n        // After\n        if (this[symbols.currentEffect] === effect) {\n          this[symbols.currentEffect] = null;\n          this[symbols.afterEffect](effect);\n        }\n      });\n    }\n\n  }\n\n  return TransitionEffect;\n}\n\n\nfunction getTransitionElements(element, effect) {\n  return element[symbols.elementsWithTransitions] ?\n    element[symbols.elementsWithTransitions](effect) :\n    [element];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/TransitionEffectMixin.js","/**\n * This helper returns a guess as to what portion of the given element can be\n * scrolled. This is used by [SelectionInViewMixin](SelectionInViewMixin) to\n * provide a default implementation of [symbols.scrollTarget].\n *\n * If the element has a shadow root containing a default (unnamed) slot, this\n * returns the first ancestor of that slot that has either `overflow-x` or\n * `overflow-y` styled as `auto` or `scroll`. If the element has no default\n * slot, or no scrolling ancestor is found, the element itself is returned.\n *\n * @param {HTMLElement} element – the component to examine for a scrolling\n * element\n * @returns {HTMLElement}\n */\nfunction defaultScrollTarget(element) {\n  const root = element.shadowRoot;\n  const slot = root && root.querySelector('slot:not([name])');\n  const scrollingParent = slot && getScrollingParent(slot.parentNode);\n  return scrollingParent || element;\n}\n\n\n// Return the parent of the given element that can be scrolled. If no such\n// element is found, return null.\nfunction getScrollingParent(element) {\n  // We test against DocumentFragment below instead of ShadowRoot, because the\n  // polyfill doesn't define the latter, and instead uses the former. In native\n  // Shadow DOM, a ShadowRoot is a subclass of DocumentFragment, so the same\n  // test works then too.\n  if (element === null || element instanceof DocumentFragment) {\n    // Didn't find a scrolling parent.\n    return null;\n  }\n  const style = getComputedStyle(element);\n  const overflowX = style.overflowX;\n  const overflowY = style.overflowY;\n  if (overflowX === 'scroll' || overflowX === 'auto' ||\n      overflowY === 'scroll' || overflowY === 'auto') {\n    // Found an element we can scroll.\n    return element;\n  }\n  // Keep looking higher in the hierarchy for a scrolling parent.\n  return getScrollingParent(element.parentNode);\n}\n\n\nexport default defaultScrollTarget;\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/defaultScrollTarget.js","/**\n * This is a helper function for rendering an array of items as elements.\n * You can use this if your component nees to generate a set of elements for\n * each item in an array.\n *\n * Example: The following will render an array of strings in divs as children\n * of the `container` element:\n *\n *     let strings = ['a', 'b', 'c', ...];\n *     let container = this.querySelector(...);\n *     renderArrayAsElements(strings, container, (string, element) => {\n *       if (!element || element.localName !== 'div') {\n *         // Create a new div.\n *         element = document.createElement('div');\n *       }\n *       // Set/update the text content of the element.\n *       element.textContent = string;\n *       return element;\n *     });\n *\n * The `renderArrayAsElements` function will reuse existing elements if\n * possible. E.g., if it is called to render an array of 4 items, and later\n * called to render an array of 5 items, it can reuse the existing 4 items,\n * creating just one new element. Note, however, that this re-rendering is not\n * automatic. If, after calling this function, you manipulate the array you\n * used, you must still call this function again to re-render the array.\n *\n * The `renderItem` parameter takes a function of two arguments: an item to\n * to render, and an existing element (if one exists) which can be repurposed to\n * render that item. If the latter argument is null, the `renderItem()` function\n * should create a new element and return it. The function should do the same\n * if the supplied existing element is not suitable for rendering the given\n * item; the returned element will be used to replace the existing one. If the\n * existing element *is* suitable, the function can simply update it and return\n * it as is.\n *\n * @param {Array} items - the items to render\n * @param {Element} container - the parent that will hold the elements\n * @param {Function} renderItem - returns a new\n *   element for an item, or repurposes an existing element for an item\n */\nfunction renderArrayAsElements(items, container, renderItem) {\n  // Create a new set of elements for the current items.\n  items.forEach((item, index) => {\n    const oldElement = container.children[index];\n    const newElement = renderItem(item, oldElement);\n    if (newElement) {\n      if (!oldElement) {\n        container.appendChild(newElement);\n      } else if (newElement !== oldElement) {\n        container.replaceChild(newElement, oldElement);\n      }\n      // @ts-ignore\n      if (window.ShadyCSS && !window.ShadyCSS.nativeShadow) {\n        // Apply styling\n        // @ts-ignore\n        window.ShadyCSS.styleElement(newElement);\n      }\n    }\n  });\n\n  // If the array shrank, remove the extra elements which are no longer needed.\n  while (container.children.length > items.length) {\n    container.removeChild(container.children[items.length]);\n  }\n}\n\nexport default renderArrayAsElements;\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/renderArrayAsElements.js","import Symbol from './Symbol.js';\n\n\nconst webkitUserSelectKey = Symbol('webkitUserSelect');\n\n\n// Determine whether we're in a sufficiently old version of WebKit that we need\n// to apply a fix for style updates. This can't be determined via feature\n// detection, so we have to explicitly inspect the browser version.\nconst browserVersionMatch = /AppleWebKit\\/([\\d.]+)/.exec(navigator.userAgent);\nconst needsForceFix = /Apple Computer/.test(navigator.vendor) && browserVersionMatch && parseInt(browserVersionMatch[1]) <= 603;\n\n\n/**\n * This function works around a bug in the initial Shadow DOM implementation in\n * Apple Safari and Mobile Safari:\n * https://bugs.webkit.org/show_bug.cgi?id=170762. This bug prevents component\n * CSS from correctly applying style rules that depend on CSS classes or\n * attributes applied to the component host. This bug was fixed in WebKit\n * version 604, but older WebKit versions need this fix.\n * \n * The fix entails forcing a temporary change in a CSS property on the component\n * that will force a style recalc. For this purpose, the \"-webkit-user-select\"\n * property is used. In the next tick, we revert that change.\n *  \n * @param {HTMLElement} element \n */\nexport function webkitForceStyleUpdate(element) {\n  // Only do our fix if we're in an old version of WebKit and we're not already\n  // set up to do the fix.\n  if (needsForceFix && element[webkitUserSelectKey] == null) {\n    // Get the current value of -webkit-user-select directly on the component.\n    element[webkitUserSelectKey] = element.style.webkitUserSelect || '';\n    const effectiveWebkitUserSelect = getComputedStyle(element).webkitUserSelect;\n    // Apply a value for -webkit-user-select that differs from the current\n    // value.\n    element.style.webkitUserSelect = effectiveWebkitUserSelect === 'none' ?\n      'text' :\n      'none';\n    setTimeout(() => {\n      // Revert the change.\n      element.style.webkitUserSelect = element[webkitUserSelectKey];\n      element[webkitUserSelectKey] = null;\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/utilities.js","import symbols from '../mixins/symbols.js';\n\n\n/**\n * This mixin wraps a component’s template to add a backdrop element suitable\n * for use in modal overlays such as dialogs. The backdrop plays two roles: the\n * it prevents background clicks, and it can be styled (with, for example, a\n * semi-transparent background color) to help focus the user’s attention away\n * from the page background and toward the overlay. This wrapper is often used\n * in conjunction with `DialogModalityMixin`.\n * \n * This wrapper expects the component to provide:\n * \n * * A template-stamping mechanism compatible with `ShadowTemplateMixin`.\n * \n * The wrapper provides these features to the component:\n * \n * * A container element identified as `#overlayContent` that holds the\n *   element’s primary content.\n * * A backdrop element identified as `#backdrop` that sits behind the primary\n *   content and covers the viewport.\n * \n * By default, `BackdropWrapper` provides no styling of the backdrop. If you are\n * using this wrapper in your component, the elements added by the wrapper will\n * be in your component’s shadow tree, so you can style them like any shadow\n * element.\n *\n * @module BackdropWrapper\n */\nexport default function BackdropWrapper(base) {\n\n  // The class prototype added by the mixin.\n  class Backdrop extends base {\n\n    get backdrop() {\n      return this.shadowRoot.querySelector('#backdrop');\n    }\n\n    [symbols.template](filler) {\n      const template = `\n        <style>\n          :host {\n            height: 100%;\n            left: 0;\n            outline: none;\n            position: fixed;\n            top: 0;\n            -webkit-tap-highlight-color: transparent;\n            width: 100%;\n          }\n\n          #backdrop {\n            height: 100%;\n            left: 0;\n            position: absolute;\n            top: 0;\n            user-select: none;\n            width: 100%;\n          }\n\n          #overlayContent {\n            position: relative;\n          }\n        </style>\n        <div id=\"backdrop\" role=\"none\"></div>\n        <div id=\"overlayContent\" role=\"none\">\n          ${filler || `<slot></slot>`}\n        </div>\n      `;\n      return super[symbols.template] ?\n        super[symbols.template](template) :\n        template;\n    }\n  }\n\n  return Backdrop;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/BackdropWrapper.js","import Symbol from '../mixins/Symbol.js';\nimport symbols from '../mixins/symbols.js';\n\n\n// Symbols for private data members on an element.\nconst wrappingFocusKey = Symbol('wrappingFocus');\n\n\n/**\n * This mixin wraps a component’s template such that, once the component gains\n * the keyboard focus, Tab and Shift+Tab operations will cycle the focus within\n * the component.\n * \n * This wrapper expects the component to provide:\n * \n * * A template-stamping mechanism compatible with `ShadowTemplateMixin`.\n * \n * The wrapper provides these features to the component:\n * \n * * Template elements and event handlers that will cause the keyboard focus to wrap.\n *\n * @module FocusCaptureWrapper\n */\nexport default function FocusCaptureWrapper(base) {\n\n  class FocusCapture extends base {\n\n    [symbols.keydown](event) {\n      let handled;\n\n      /** @type {any} */\n      const element = this;\n      if (document.activeElement === element &&\n          this.shadowRoot.activeElement === null &&\n          event.keyCode === 9 && event.shiftKey) {\n        // Set focus to focus catcher.\n        // The Shift+Tab keydown event should continue bubbling, and the default\n        // behavior should cause it to end up on the last focusable element.\n        this[wrappingFocusKey] = true;\n        const focusCatcher = this.shadowRoot.querySelector('#focusCatcher');\n        focusCatcher.focus();\n        this[wrappingFocusKey] = false;\n        handled = true;\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event)) || false;\n    }\n\n    [symbols.shadowCreated]() {\n      if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n\n      const focusCatcher = this.shadowRoot.querySelector('#focusCatcher');\n      focusCatcher.addEventListener('focus', event => {\n        if (!this[wrappingFocusKey]) {\n          // Wrap focus back to the dialog.\n          this.focus();\n        }\n      });\n    }\n\n    [symbols.template](filler) {\n      const template = `\n        ${filler || `<slot></slot>`}\n        <div id=\"focusCatcher\" tabindex=\"0\"></div>\n      `;\n      return super[symbols.template] ?\n        super[symbols.template](template) :\n        template;\n    }\n\n  }\n\n  return FocusCapture;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/FocusCaptureWrapper.js","import FocusRingMixin from '../mixins/FocusRingMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport symbols from '../mixins/symbols.js';\n\n\n/**\n * A classic rounded tab button.\n *\n * This component is used by [LabeledTabs](LabeledTabs), which will generate\n * an instance of `LabeledTabButton` for each panel in a set of tab panels.\n *\n * @extends HTMLElement\n * @mixes FocusRingMixin\n * @mixes ShadowTemplateMixin\n */\nclass LabeledTabButton extends FocusRingMixin(ShadowTemplateMixin(HTMLElement)) {\n  [symbols.template](filler) {\n    return `\n      <style>\n        :host {\n          display: inline-flex;\n        }\n\n        :host(:focus:not(.focus-ring)) {\n          outline: none;\n        }\n\n        button {\n          background: white;\n          border: 1px solid #ccc;\n          cursor: pointer;\n          flex: 1;\n          font-family: inherit;\n          font-size: inherit;\n          margin: 0;\n          outline: none;\n          padding: 0.5em 0.75em;\n          position: relative;\n          -webkit-tap-highlight-color: transparent;\n          transition: border-color 0.25s;\n        }\n\n        :host(.selected) button {\n          border-color: #ccc;\n          opacity: 1;\n        }\n\n        :host(:hover) button {\n          background-color: #eee;\n        }\n\n        /* top/bottom positions */\n        :host([tab-position=\"top\"]:not(:last-child)),\n        :host([tab-position=\"bottom\"]:not(:last-child)) {\n          margin-right: 0.2em;\n        }\n\n        /* top position */\n        :host([tab-position=\"top\"]) button {\n          border-radius: 0.25em 0.25em 0 0;\n          margin-bottom: -1px;\n        }\n        :host([tab-position=\"top\"].selected) button {\n          border-bottom-color: transparent;\n        }\n\n        /* bottom position */\n        :host([tab-position=\"bottom\"]) button {\n          border-radius: 0 0 0.25em 0.25em;\n          margin-top: -1px;\n        }\n        :host([tab-position=\"bottom\"].selected) button {\n          border-top-color: transparent;\n        }\n\n        /* left/right positions */\n        :host([tab-position=\"left\"]:not(:last-child)),\n        :host([tab-position=\"right\"]:not(:last-child)) {\n          margin-bottom: 0.2em;\n        }\n\n        /* left position */\n        :host([tab-position=\"left\"]) button {\n          border-radius: 0.25em 0 0 0.25em;\n          margin-right: -1px;\n        }\n        :host([tab-position=\"left\"].selected) button {\n          border-right-color: transparent;\n        }\n\n        /* right position */\n        :host([tab-position=\"right\"]) button {\n          border-radius: 0 0.25em 0.25em 0;\n          margin-left: -1px;\n        }\n        :host([tab-position=\"right\"].selected) button {\n          border-left-color: transparent;\n        }\n      </style>\n\n      <button tabindex=\"-1\">\n        ${filler || `<slot></slot>`}\n      </button>\n    `;\n  }\n}\n\n\ncustomElements.define('elix-labeled-tab-button', LabeledTabButton);\nexport default LabeledTabButton;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/LabeledTabButton.js","import AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\nimport ClickSelectionMixin from '../mixins/ClickSelectionMixin.js';\nimport ContentItemsMixin from '../mixins/ContentItemsMixin.js';\nimport DefaultSlotContentMixin from '../mixins/DefaultSlotContentMixin.js';\nimport DirectionSelectionMixin from '../mixins/DirectionSelectionMixin.js';\nimport KeyboardDirectionMixin from '../mixins/KeyboardDirectionMixin.js';\nimport KeyboardMixin from '../mixins/KeyboardMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport SingleSelectionMixin from '../mixins/SingleSelectionMixin.js';\nimport Symbol from '../mixins/Symbol.js';\nimport symbols from '../mixins/symbols.js';\nimport * as utilities from '../mixins/utilities.js';\n\n\n// Symbols for private data members on an element.\nconst tabAlignKey = Symbol('tabAlign');\nconst tabPositionKey = Symbol('tabPosition');\n\n\nconst Base =\n  AttributeMarshallingMixin(\n  ClickSelectionMixin(\n  ContentItemsMixin(\n  DefaultSlotContentMixin(\n  DirectionSelectionMixin(\n  KeyboardDirectionMixin(\n  KeyboardMixin(\n  ShadowTemplateMixin(\n  SingleSelectionMixin(\n    HTMLElement\n  )))))))));\n\n\n/**\n * A container for a set of tab buttons.\n *\n * `TabStrip` is specifically responsible for handling keyboard navigation\n * between tab buttons, and for the visual layout of the buttons.\n *\n * The user can select a tab with the mouse or touch, as well as by through the\n * keyboard. Each tab appears as a separate button in the tab order.\n * Additionally, if the focus is currently on a tab, the user can quickly\n * navigate between tabs with the left/right arrow keys (or, if the tabs are\n * in vertical position, the up/down arrow keys).\n *\n * By default, the tabs are shown aligned to the left (in left-to-right\n * languages like English), where each tab is only as big as necessary. You\n * can adjust the alignment of the tabs with the `tabAlign` property.\n *\n * The component assumes that the tab buttons will appear above the tab panels\n * they control. You can adjust that positioning with the `tabPosition`\n * property.\n *\n * A `TabStrip` is often wrapped around a set of tab panels, a scenario which\n * can be handled with the separate [TabStripWrapper](TabStripWrapper)\n * component.\n *\n * @extends HTMLElement\n * @mixes AttributeMarshallingMixin\n * @mixes ClickSelectionMixin\n * @mixes ContentItemsMixin\n * @mixes DefaultSlotContentMixin\n * @mixes DirectionSelectionMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardDirectionMixin\n * @mixes ShadowTemplateMixin\n * @mixes SingleSelectionMixin\n */\nclass TabStrip extends Base {\n\n  constructor() {\n    super();\n\n    // Set defaults.\n    const defaults = this[symbols.defaults];\n    if (typeof this.tabAlign === 'undefined') {\n      this.tabAlign = defaults.tabAlign;\n    }\n    if (typeof this.tabPosition === 'undefined') {\n      this.tabPosition = defaults.tabPosition;\n    }\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.tabindex = null;\n    defaults.tabAlign = 'start';\n    defaults.tabPosition = 'top';\n    defaults.selectionRequired = true;\n    return defaults;\n  }\n\n  [symbols.itemAdded](item) {\n    if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    item.setAttribute('role', 'tab');\n    item.setAttribute('tabindex', 0);\n  }\n\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    if (selected) {\n      item.classList.add('selected');\n    } else {\n      item.classList.remove('selected');\n    }\n    item.setAttribute('aria-selected', selected);\n    utilities.webkitForceStyleUpdate(item);\n  }\n\n  [symbols.keydown](event) {\n\n    let handled;\n\n    // Let user select a tab button with Enter or Space.\n    switch (event.keyCode) {\n      case 13: /* Enter */\n      case 32: /* Space */\n        const index = this.items.indexOf(event.target);\n        if (index !== this.selectedIndex) {\n          this.selectedIndex = index;\n          handled = true;\n        }\n        break;\n    }\n\n    // Give mixins a chance to do work.\n    handled = handled || (super[symbols.keydown] && super[symbols.keydown](event));\n\n    if (handled && this.selectedItem instanceof HTMLElement) {\n      // If the event resulted in a change of selection, move the focus to the\n      // newly-selected tab.\n      this.selectedItem.focus();\n    }\n\n    return handled;\n  }\n\n  /**\n   * @type {string}\n   */\n  get tabAlign() {\n    return this[tabAlignKey];\n  }\n  set tabAlign(tabAlign) {\n    this[tabAlignKey] = tabAlign;\n    this.reflectAttribute('tab-align', tabAlign);\n  }\n\n  /**\n   * The position of the tab strip relative to the element's children. Valid\n   * values are \"top\", \"left\", \"right\", and \"bottom\".\n   *\n   * @default \"top\"\n   * @type {string}\n   */\n  get tabPosition() {\n    return this[tabPositionKey];\n  }\n  set tabPosition(tabPosition) {\n    this[tabPositionKey] = tabPosition;\n    this.reflectAttribute('tab-position', tabPosition);\n    this.navigationAxis = (tabPosition === 'top' || tabPosition === 'bottom') ?\n      'horizontal' :\n      'vertical';\n\n    // Let tabs know their tab position, too.\n    [].forEach.call(this.items, tab => {\n      tab.setAttribute('tab-position', tabPosition);\n      utilities.webkitForceStyleUpdate(tab);\n    });\n  }\n\n  [symbols.template](filler) {\n    return `\n      <style>\n        :host {\n          display: inline-flex;\n        }\n\n        /*\n         * Avoid having tab container stretch across. User won't be able to see\n         * it, but since it handles the keyboard, in Mobile Safari a tap on the\n         * container background will cause the region to flash. Aligning the\n         * region collapses it down to hold its contents.\n         */\n        #tabButtonContainer {\n          /* For IE bug (clicking tab produces gap between tab and page). */\n          display: flex;\n          flex-direction: row;\n          flex: 1;\n          /*\n           * Try to obtain fast-tap behavior on all tabs.\n           * See https://webkit.org/blog/5610/more-responsive-tapping-on-ios/.\n           */\n          touch-action: manipulation;\n        }\n\n        /* Left/right positions */\n        :host([tab-position=\"left\"]) #tabButtonContainer,\n        :host([tab-position=\"right\"]) #tabButtonContainer {\n          flex-direction: column;\n        }\n\n        /* Alignment */\n        :host([tab-align=\"start\"]) #tabButtonContainer {\n          justify-content: flex-start;\n        }\n        :host([tab-align=\"center\"]) #tabButtonContainer {\n          justify-content: center;\n        }\n        :host([tab-align=\"end\"]) #tabButtonContainer {\n          justify-content: flex-end;\n        }\n        :host([tab-align=\"stretch\"]) #tabButtonContainer > ::slotted(*) {\n          flex: 1;\n        }\n      </style>\n\n      <div id=\"tabButtonContainer\" role=\"none\">\n        ${filler || `<slot></slot>`}\n      </div>\n    `;\n  }\n}\n\n\ncustomElements.define('elix-tab-strip', TabStrip);\nexport default TabStrip;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/TabStrip.js","import symbols from '../mixins/symbols.js';\nimport TabStrip from './TabStrip.js'; // jshint ignore:line\n\n\n// Used to assign unique IDs to tabs for ARIA purposes.\nlet idCount = 0;\n\n\n/**\n * A wrapper which adds strip of tabs for selecting one of the component's\n * children.\n *\n * The `TabStripWrapper` component does not define how a selected child is\n * represented. If you're looking for the standard behavior of just showing only\n * the selected child, you can use `TabStripWrapper` in combination with the\n * separate [Modes](Modes) component. The above combination is so common it\n * is provided as a single component, [Tabs](Tabs).\n *\n * `TabStripWrapper` defines a slot named \"tabButtons\" into which you can slot\n * the buttons that will be used to select the tab panels. That slot sits inside\n * a [TabStrip](TabStrip) instance, which handles keyboard navigation and\n * the ordering of the tab buttons.\n *\n * @module TabStripWrapper\n */\nexport default function TabStripWrapper(Base) {\n\n  class TabStripWrap extends Base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the overall component.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n\n      // Ensure we reflect attributes.\n      const defaults = this[symbols.defaults];\n      if (!this.getAttribute('tab-align')) {\n        this.tabAlign = defaults.tabAlign;\n      }\n      if (!this.getAttribute('tab-position')) {\n        this.tabPosition = defaults.tabPosition;\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'tablist';\n      defaults.tabAlign = 'start';\n      defaults.tabPosition = 'top';\n      return defaults;\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      if (!this.items) {\n        return;\n      }\n\n      const baseId = this.id ?\n        \"_\" + this.id + \"Panel\" :\n        \"_panel\";\n\n      // Confirm that items have at least a default role and ID for ARIA purposes.\n      this.items.forEach(item => {\n        if (!item.getAttribute('role')) {\n          item.setAttribute('role', 'tabpanel');\n        }\n        if (!item.id) {\n          item.id = baseId + idCount++;\n        }\n      });\n    }\n\n    get pages() {\n      return this.shadowRoot.querySelector('#pages');\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(value) {\n      if ('selectedIndex' in Base.prototype) { super.selectedIndex = value; }\n      if (this.tabStrip.selectedIndex !== value) {\n        this.tabStrip.selectedIndex = value;\n      }\n    }\n\n    [symbols.shadowCreated]() {\n      if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n      this.tabStrip.addEventListener('selected-index-changed', event => {\n        if (event instanceof CustomEvent) {\n          this.selectedIndex = event.detail.selectedIndex;\n        }\n      });\n    }\n\n    get tabAlign() {\n      return this.tabStrip.tabAlign;\n    }\n    set tabAlign(tabAlign) {\n      if (this.tabStrip.tabAlign !== tabAlign) {\n        this.tabStrip.tabAlign = tabAlign;\n      }\n      if (this.getAttribute('tab-align') !== tabAlign) {\n        this.setAttribute('tab-align', tabAlign);\n      }\n    }\n\n    get tabPosition() {\n      return this.tabStrip.tabPosition;\n    }\n    set tabPosition(tabPosition) {\n      if (this.tabStrip.tabPosition !== tabPosition) {\n        this.tabStrip.tabPosition = tabPosition;\n      }\n      if (this.getAttribute('tab-position') !== tabPosition) {\n        this.setAttribute('tab-position', tabPosition);\n      }\n\n      // Physically reorder the tabs and pages to reflect the desired arrangement.\n      // We could change the visual appearance by reversing the order of the flex\n      // box, but then the visual order wouldn't reflect the document order, which\n      // determines focus order. That would surprise a user trying to tab through\n      // the controls.\n      const topOrLeft = (tabPosition === 'top' || tabPosition === 'left');\n      const firstElement = topOrLeft ?\n        this.tabStrip :\n        this.pages;\n      const lastElement = topOrLeft ?\n        this.pages :\n        this.tabStrip;\n      if (!this.shadowRoot) {\n        console.warn(`TabStripWrapper expects a component to define a shadowRoot.`);\n      } else if (firstElement.nextSibling !== lastElement) {\n        this.shadowRoot.insertBefore(firstElement, lastElement);\n      }\n    }\n\n    get tabs() {\n      return this.tabStrip.items;\n    }\n\n    /**\n     * @type {TabStrip}\n     */\n    get tabStrip() {\n      return this.shadowRoot.querySelector('#tabStrip');\n    }\n\n    [symbols.template](fillers = {}) {\n      const defaultFiller = typeof fillers === 'string' ?\n        fillers :\n        fillers.default || `<slot></slot>`;\n      const tabButtonsFiller = fillers.tabButtons || `<slot name=\"tabButtons\"></slot>`;\n      return super[symbols.template](`\n        <elix-tab-strip id=\"tabStrip\">\n          ${tabButtonsFiller}\n        </elix-tab-strip>\n\n        <div id=\"pages\">\n          ${defaultFiller}\n        </div>\n\n        <style>\n          :host {\n            display: inline-flex;\n            flex-direction: column;\n            position: relative;\n          }\n\n          #pages {\n            display: flex;\n            flex: 1;\n            flex-direction: column;\n          }\n\n          #pages ::slotted(*) {\n            display: flex;\n            flex: 1;\n          }\n\n          /* Left/right positions */\n          :host([tab-position=\"left\"]),\n          :host([tab-position=\"right\"]) {\n            flex-direction: row;\n          }\n\n          /* Generic style */\n          #pages {\n            background: white;\n            border: 1px solid #ccc;\n            box-sizing: border-box;\n          }\n        </style>\n      `);\n    }\n\n  }\n\n  return TabStripWrap;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/TabStripWrapper.js","import Modes from './Modes.js';\nimport TabStripWrapper from './TabStripWrapper.js';\n\n\n/**\n * A set of pages with a tab strip governing which page is shown.\n *\n * Use tabs when you want to provide a large set of options or elements than\n * can comfortably fit inline, the options can be coherently grouped into pages,\n * and you want to avoid making the user navigate to a separate page. Tabs work\n * best if you only have a small handful of pages, say 2–7.\n *\n * This stock combination applies the [TabStripWrapper](TabStripWrapper) to a\n * [Modes](Modes) element. The former takes care of the relative positioning\n * of the tab buttons and tab panels; the latter takes care of displaying only\n * the currently-selected tab panel. If you'd like to create something more\n * complex than this arrangement, you can use either of those elements on its\n * own.\n *\n * You will need to provide `Tabs` with the buttons that will select the\n * corresponding tab panels. Do this by slotting the buttons into the slot named\n * \"tabButtons\". If you don't require custom tab buttons, you can use the more\n * specialized [LabeledTabs](LabeledTabs) component, which will generate text\n * tab buttons for you.\n *\n * @extends Modes\n * @mixes TabStripWrapper\n */\nclass Tabs extends TabStripWrapper(Modes) {}\n\n\ncustomElements.define('elix-tabs', Tabs);\nexport default Tabs;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/Tabs.js","import Symbol from '../mixins/Symbol.js';\nimport symbols from './symbols.js';\n\n\n// Symbols for private data members on an element.\nconst previousBodyOverflowKey = Symbol('previousBodyStyleOverflow');\nconst previousDocumentMarginRightKey = Symbol('previousDocumentMarginRight');\n\n\n/**\n * This mixin blocks various user interactions to make an overlay behave like a\n * modal dialog. This mixin is generally used in conjunction with a backdrop\n * (such as that provided by `BackdropWrapper`).\n * \n * This mixin expects the component to provide:\n * \n * * An open/close API compatible with `OpenCloseMixin`.\n * \n * The mixin provides these features to the component:\n * \n * * Disables scrolling on the background page.\n * * A default ARIA role of `dialog`.\n * * Closes the element if user presses the Esc key.\n * \n * For modeless overlays, see `PopupModalityMixin` instead.\n * \n * @module DialogModalityMixin\n */\nexport default function DialogModalityMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class DialogModality extends Base {\n\n    [symbols.afterEffect](effect) {\n      if (super[symbols.afterEffect]) { super[symbols.afterEffect](effect); }\n      if (effect === 'closing') {\n        // Restore body's previous degree of scrollability.\n        document.body.style.overflow = this[previousBodyOverflowKey];\n        document.documentElement.style.marginRight = this[previousDocumentMarginRightKey];\n      }\n    }\n\n    [symbols.beforeEffect](effect) {\n      if (super[symbols.beforeEffect]) { super[symbols.beforeEffect](effect); }\n      if (effect === 'opening') {\n        // Mark body as non-scrollable, to absorb space bar keypresses and other\n        // means of scrolling the top-level document.\n        const scrollBarWidth = window.innerWidth - document.body.clientWidth;\n        this[previousBodyOverflowKey] = document.body.style.overflow;\n        this[previousDocumentMarginRightKey] = scrollBarWidth > 0 ?\n          document.documentElement.style.marginRight :\n          null;\n        document.body.style.overflow = 'hidden';\n        if (scrollBarWidth > 0) {\n          document.documentElement.style.marginRight = `${scrollBarWidth}px`;\n        }\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the dialog.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'dialog';\n      return defaults;\n    }\n\n    [symbols.keydown](event) {\n      let handled = false;\n\n      switch (event.keyCode) {\n\n        case 27: // Escape\n          // Close on Esc key.\n          this.close();\n          handled = true;\n          break;\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event)) || false;\n    }\n  }\n\n  return DialogModality;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/DialogModalityMixin.js","import symbols from './symbols.js';\n\n\n/**\n * This mixin creates references to elements in a component's Shadow DOM subtree.\n *\n * This adds a member on the component called `this.$` that can be used to\n * reference shadow elements with IDs. E.g., if component's shadow contains an\n * element `<button id=\"foo\">`, then this mixin will create a member\n * `this.$.foo` that points to that button.\n *\n * Such references simplify a component's access to its own elements. In\n * exchange, this mixin trades off a one-time cost of querying all elements in\n * the shadow tree instead of paying an ongoing cost to query for an element\n * each time the component wants to inspect or manipulate it.\n *\n * This mixin expects the component to define a Shadow DOM subtree and, when\n * that has been done, to invoke [symbols.shadowCreated](symbols#shadowCreated).\n * You can create the shadow subtree yourself, or make use of\n * [ShadowTemplateMixin](ShadowTemplateMixin).\n *\n * This mixin is inspired by Polymer's [automatic\n * node finding](https://www.polymer-project.org/1.0/docs/devguide/local-dom.html#node-finding)\n * feature.\n *\n * @module ShadowReferencesMixin\n */\nexport default function ShadowReferencesMixin(Base) {\n\n  class ShadowReferences extends Base {\n\n    [symbols.shadowCreated]() {\n      if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n      if (this.shadowRoot) {\n        // Look for elements in the shadow subtree that have id attributes.\n        // An alternatively implementation of this mixin would be to just define\n        // a this.$ getter that lazily does this search the first time someone\n        // tries to access this.$. That might introduce some complexity – if the\n        // the tree changed after it was first populated, the result of\n        // searching for a node might be somewhat unpredictable.\n        if (!this.$) {\n          this.$ = {};\n        }\n        const nodesWithIds = this.shadowRoot.querySelectorAll('[id]');\n        const $ = this.$;\n        [].forEach.call(nodesWithIds, node => {\n          const id = node.getAttribute('id');\n          $[id] = node;\n        });\n      }\n    }\n\n    /**\n     * The collection of references to the elements with IDs in a component's\n     * Shadow DOM subtree.\n     *\n     * @type {object}\n     * @member $\n     */\n  }\n\n  return ShadowReferences;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/ShadowReferencesMixin.js","/**\n * A collection of constants used by Elix mixins and components for consistency\n * in things such as user interface timings.\n *\n * @module constants\n */\nconst constants = {\n\n  /**\n   * Time in milliseconds after which the user is considered to have stopped\n   * typing.\n   *\n   * This is used by\n   * [KeyboardPrefixSelectionMixin](KeyboardPrefixSelectionMixin).\n   *\n   * @const {number} TYPING_TIMEOUT_DURATION\n   */\n  TYPING_TIMEOUT_DURATION: 1000\n\n};\n\n\nexport default constants;\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/constants.js","/**\n * These functions help access component content.\n *\n * @module content\n */\n\n/**\n * Return a set of Elements which are likely to be useful as component content.\n *\n * Given a `NodeList` or array of objects, this will return only those array\n * members that are: a) instances of `Element` (`HTMLElement` or `SVGElement`),\n * and b) not on a blacklist of normally invisible elements (such as `style` or\n * `script`). Among other things, this filters out Text nodes.\n *\n * This is used by [ContentItemsMixin](ContentItemsMixin) to filter out nodes\n * which are unlikely to be interesting as list items.\n *\n * @param {NodeList|Node[]} nodes - the list of nodes to filter\n * @returns {Element[]} the filtered elements\n */\nexport function substantiveElements(nodes) {\n\n  // These are tags for elements that can appear in the document body, but do\n  // not seem to have any user-visible manifestation.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n  const auxiliaryElementTags = [\n    'applet',         // deprecated\n    'basefont',       // deprecated\n    'embed',\n    'font',           // deprecated\n    'frame',          // deprecated\n    'frameset',       // deprecated\n    'isindex',        // deprecated\n    'keygen',         // deprecated\n    'link',\n    'multicol',       // deprecated\n    'nextid',         // deprecated\n    'noscript',\n    'object',\n    'param',\n    'script',\n    'style',\n    'template',\n    'noembed'         // deprecated\n  ];\n\n  return [].filter.call(nodes,\n    node => node instanceof Element &&\n        (!node.localName || auxiliaryElementTags.indexOf(node.localName) < 0)\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/content.js","/**\n * Returns true if the first node contains (or is) the second, even if the\n * second node is in a shadow tree.\n *\n * The standard Node.contains() function does not account for Shadow DOM, and\n * returns false if the supplied target node is sitting inside a shadow tree\n * within the container.\n * \n * @param {Node} container - The container to search within.\n * @param {Node} target - The node that may be inside the container.\n * @returns {boolean} - True if the container contains the target node.\n */\nexport default function deepContains(container, target) {\n  /** @type {any} */\n  let current = target;\n  while (current) {\n    if (container === current) {\n      return true;\n    }\n    current = current.parentNode || current.host;\n  }\n  return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/deepContains.js","// jshint ignore:start\n\n// We assume we'll want to provide demos of most or all of Elix itself.\nimport * as Elix from '../globals.js';\n\n// Additional demo components.\nimport BrowserPluginList from './src/BrowserPluginList.js';\nimport FocusRingTest from './src/FocusRingTest.js';\nimport ModesWithKeyboard from './src/ModesWithKeyboard.js';\nimport QuietButton from './src/QuietButton.js';\nimport SampleDialog from './src/SampleDialog.js';\nimport SingleSelectionDemo from './src/SingleSelectionDemo.js';\nimport ToolbarTab from './src/ToolbarTab.js';\n\n// jshint ignore:end\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demos.js","/*\n * Demo of a list box with hard-coded contents.\n * As a list source, this enumerates `navigator.plugins`.\n */\n\n\nimport AttributeMarshallingMixin from '../../mixins/AttributeMarshallingMixin.js';\nimport ClickSelectionMixin from '../../mixins/ClickSelectionMixin.js';\nimport ContentItemsMixin from '../../mixins/ContentItemsMixin.js';\nimport DirectionSelectionMixin from '../../mixins/DirectionSelectionMixin.js';\nimport KeyboardDirectionMixin from '../../mixins/KeyboardDirectionMixin.js';\nimport KeyboardMixin from '../../mixins/KeyboardMixin.js';\nimport KeyboardPagedSelectionMixin from '../../mixins/KeyboardPagedSelectionMixin.js';\nimport KeyboardPrefixSelectionMixin from '../../mixins/KeyboardPrefixSelectionMixin.js';\nimport SelectionAriaMixin from '../../mixins/SelectionAriaMixin.js';\nimport SelectionInViewMixin from '../../mixins/SelectionInViewMixin.js';\nimport ShadowTemplateMixin from '../../mixins/ShadowTemplateMixin.js';\nimport SingleSelectionMixin from '../../mixins/SingleSelectionMixin.js';\nimport symbols from '../../mixins/symbols.js';\nimport { toggleClass } from '../../mixins/attributes.js';\n\n\nconst Base =\n  AttributeMarshallingMixin(\n  ClickSelectionMixin(\n  ContentItemsMixin(\n  DirectionSelectionMixin(\n  KeyboardDirectionMixin(\n  KeyboardMixin(\n  KeyboardPagedSelectionMixin(\n  KeyboardPrefixSelectionMixin(\n  SelectionAriaMixin(\n  SelectionInViewMixin(\n  ShadowTemplateMixin(\n  SingleSelectionMixin(\n    HTMLElement\n  ))))))))))));\n\n\nclass BrowserPluginList extends Base {\n\n  get [symbols.content]() {\n    if (this.shadowRoot) {\n      const container = this.shadowRoot.querySelector('#devicesContainer');\n      if (container) {\n        return container.children;\n      }\n    }\n    return [];\n  }\n\n  // We define a collection of default property values which can be set in\n  // the constructor or connectedCallback. Defining the actual default values\n  // in those calls would complicate things if a subclass someday wants to\n  // define its own default value.\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    // By default, we assume the list presents list items vertically.\n    defaults.orientation = 'vertical';\n    return defaults;\n  }\n\n  // HACK to work around limitations of pre-v1 ShadyCSS.\n  [symbols.itemAdded](item) {\n    if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n    item.classList.add('style-scope');\n    item.classList.add('browser-plugin-list');\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    toggleClass(item, 'selected', selected);\n  }\n\n  [symbols.shadowCreated]() {\n    if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n    const choices = Array.prototype.map.call(navigator.plugins, plugin => plugin.name);\n    const sorted = choices.sort();\n    setOptions(this, sorted);\n  }\n\n  // Define a template that will be stamped into the Shadow DOM by the\n  // ShadowTemplateMixin.\n  [symbols.template]() {\n    return `\n      <style>\n      :host {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n        display: inline-flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      #devicesContainer {\n        flex: 1;\n        -webkit-overflow-scrolling: touch; /* for momentum scrolling */\n        overflow-x: hidden;\n        overflow-y: scroll;\n      }\n\n      #devicesContainer > * {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      #devicesContainer > .selected {\n        background: highlight;\n        color: highlighttext;\n      }\n      </style>\n\n      <div id=\"devicesContainer\" role=\"none\"></div>\n    `;\n  }\n\n}\n\n\nfunction setOptions(element, options) {\n  const container = element.shadowRoot.querySelector('#devicesContainer');\n  while (container.children.length > 0) {\n    container.children[0].remove();\n  }\n  const divs = options.map(option => {\n    const div = document.createElement('div');\n    div.textContent = option;\n    return div;\n  });\n  divs.forEach(option => container.appendChild(option));\n  element[symbols.contentChanged]();\n}\n\n\ncustomElements.define('browser-plugin-list', BrowserPluginList);\nexport default BrowserPluginList;\n\n\n\n// WEBPACK FOOTER //\n// ./demos/src/BrowserPluginList.js","import FocusRingMixin from '../../mixins/FocusRingMixin.js';\nimport ShadowTemplateMixin from '../../mixins/ShadowTemplateMixin.js';\nimport symbols from '../../mixins/symbols.js';\n\n\nclass FocusRingTest extends FocusRingMixin(ShadowTemplateMixin(HTMLElement)) {\n\n  [symbols.template]() {\n    return `\n      <style>\n        :host {\n          display: inline-block;\n        }\n\n        :host(:focus:not(.focus-ring)) {\n          outline: none;\n        }\n\n        button {\n          background: gray;\n          color: white;\n          font-family: inherit;\n          font-size: inherit;\n          font-style: inherit;\n          font-weight: inherit;\n          outline: none;\n        }\n      </style>\n      <button tabindex=\"-1\">\n        <slot></slot>\n      </button>\n    `;\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.setAttribute('tabindex', '0');\n  }\n\n}\n\n\ncustomElements.define('focus-ring-test', FocusRingTest);\nexport default FocusRingTest;\n\n\n\n// WEBPACK FOOTER //\n// ./demos/src/FocusRingTest.js","import DirectionSelectionMixin from '../../mixins/DirectionSelectionMixin.js';\nimport KeyboardDirectionMixin from '../../mixins/KeyboardDirectionMixin.js';\nimport KeyboardMixin from '../../mixins/KeyboardMixin.js';\nimport Modes from '../../elements/Modes.js';\nimport SelectionAriaMixin from '../../mixins/SelectionAriaMixin.js';\n\n\nconst ModesWithKeyboard =\n  DirectionSelectionMixin(\n  KeyboardDirectionMixin(\n  KeyboardMixin(\n  SelectionAriaMixin(\n    Modes\n  ))));\n\ncustomElements.define('modes-with-keyboard', ModesWithKeyboard);\nexport default ModesWithKeyboard;\n\n\n\n// WEBPACK FOOTER //\n// ./demos/src/ModesWithKeyboard.js","import FocusRingMixin from '../../mixins/FocusRingMixin.js';\nimport ShadowTemplateMixin from '../../mixins/ShadowTemplateMixin.js';\nimport symbols from '../../mixins/symbols.js';\n\n\nclass QuietButton extends FocusRingMixin(ShadowTemplateMixin(HTMLElement)) {\n  [symbols.template](filler) {\n    return `\n      <style>\n        :host {\n          display: inline-block;\n        }\n\n        :host(:focus:not(.focus-ring)) {\n          outline: none;\n        }\n\n        button {\n          background: none;\n          border: none;\n          padding: 0;\n        }\n      </style>\n\n      <button tabindex=\"0\">\n        ${ filler || `<slot></slot>`}\n      </button>\n    `;\n  }\n}\n\n\ncustomElements.define('quiet-button', QuietButton);\nexport default QuietButton;\n\n\n\n// WEBPACK FOOTER //\n// ./demos/src/QuietButton.js","import Dialog from '../../elements/Dialog.js';\nimport symbols from '../../mixins/symbols.js';\n\n\nclass SampleDialog extends Dialog {\n\n  [symbols.shadowCreated]() {\n    if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n    this.shadowRoot.querySelector('#overlayContent').addEventListener('click', () => {\n      this.close('OK');\n    });\n  }\n\n  [symbols.template](filler) {\n    return super[symbols.template](`\n      <style>\n        #message {\n          padding: 1em;\n        }\n      </style>\n      <div id=\"message\">\n        ${filler || `<slot></slot>`}\n      </div>\n    `);\n  }\n\n}\n\n\ncustomElements.define('sample-dialog', SampleDialog);\nexport default SampleDialog;\n\n\n\n// WEBPACK FOOTER //\n// ./demos/src/SampleDialog.js","import SingleSelectionMixin from '../../mixins/SingleSelectionMixin.js';\nimport symbols from '../../mixins/symbols.js';\nimport { toggleClass } from '../../mixins/attributes.js';\n\n\n/*\n * A very simple component to show the application of SingleSelectionMixin.\n *\n * For a more complete demo using SingleSelectionMixin, see the ListBox demo.\n * \n */\nclass SingleSelectionDemo extends SingleSelectionMixin(HTMLElement) {\n\n  constructor() {\n    super();\n    this.addEventListener('mousedown', event => {\n      if (event.target instanceof Element) {\n        this[symbols.raiseChangeEvents] = true;\n        this.selectedItem = event.target;\n        event.stopPropagation();\n        this[symbols.raiseChangeEvents] = false;\n      }\n    });\n  }\n\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = newValue;\n    }\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    toggleClass(item, 'selected', selected);\n  }\n\n  // Simplistic implementation of items property — doesn't handle redistribution.\n  get items() {\n    return this.children;\n  }\n\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n}\n\n\ncustomElements.define('single-selection-demo', SingleSelectionDemo);\nexport default SingleSelectionDemo;\n\n\n\n// WEBPACK FOOTER //\n// ./demos/src/SingleSelectionDemo.js","import FocusRingMixin from '../../mixins/FocusRingMixin.js';\nimport ShadowTemplateMixin from '../../mixins/ShadowTemplateMixin.js';\nimport symbols from '../../mixins/symbols.js';\n\n\nclass ToolbarTab extends FocusRingMixin(ShadowTemplateMixin(HTMLElement)) {\n  [symbols.template](filler) {\n    return `\n      <style>\n        :host {\n          display: flex;\n        }\n\n        :host(:focus:not(.focus-ring)) {\n          outline: none;\n        }\n\n        button {\n          align-items: center;\n          background: transparent;\n          border: none;\n          color: inherit;\n          display: flex;\n          flex: 1;\n          flex-direction: column;\n          font-family: inherit;\n          font-size: inherit;\n          outline: none;\n          padding: 6px;\n          -webkit-tap-highlight-color: transparent;\n        }\n\n        :host(.selected) button,\n        :host(.selected) ::slotted(*) {\n          color: dodgerblue;\n        }\n      </style>\n\n      <button tabindex=\"-1\">\n        ${filler || `<slot></slot>`}\n      </button>\n    `;\n  }\n}\n\n\ncustomElements.define('toolbar-tab', ToolbarTab);\nexport default ToolbarTab;\n\n\n\n// WEBPACK FOOTER //\n// ./demos/src/ToolbarTab.js","import Dialog from './Dialog.js';\nimport renderArrayAsElements from '../mixins/renderArrayAsElements.js';\nimport Symbol from '../mixins/Symbol.js';\nimport ShadowReferencesMixin from '../mixins/ShadowReferencesMixin.js';\nimport symbols from '../mixins/symbols.js';\n\n\nconst choicesKey = Symbol('choices');\n\n\n/**\n * An `AlertDialog` is a form of `Dialog` designed to ask the user a single\n * question and let them respond by clicking one of a small number of buttons\n * labeled with text.\n * \n * @extends {Dialog}\n * @mixes ShadowReferencesMixin\n */\nclass AlertDialog extends ShadowReferencesMixin(Dialog) {\n\n  [symbols.shadowCreated]() {\n    if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n    this.$.buttonContainer.addEventListener('click', event => {\n      // TODO: Ignore clicks on buttonContainer background.\n      if (event.target instanceof HTMLElement) {\n        const button = event.target;\n        this.close(button.textContent);\n      }\n    });\n  }\n\n  /**\n   * An array of strings indicating the choices the `AlertDialog` will present\n   * to the user as responses to the alert. For each string in the array, the\n   * `AlertDialog` displays a button labeled with that string.\n   * \n   * You can use any strings for the choices. `AlertDialog` provides static\n   * properties offering two simple arrays of choices for common situations:\n   * \n   * * `OK`: an array with the single choice \"OK\".\n   * * `OK_CANCEL`: an array with two choices, \"OK\" and “Cancel”.\n   * \n   * You can use these to set the `choices` property, or you can provide custom\n   * choices:\n   * \n   *     // Create an OK/Cancel alert.\n   *     const alert = new AlertDialog();\n   *     alert.choices = AlertDialog.OK_CANCEL;\n   *  \n   * @type {[string]}\n   */\n  get choices() {\n    return this[choicesKey];\n  }\n  /**\n   * @param {[string]} choices - The choices to present to the user\n   */\n  set choices(choices) {\n    this[choicesKey] = choices;\n    if (!this.shadowRoot) {\n      console.warn(`NotificationDialog couldn't find its own shadowRoot.`);\n      return;\n    }\n    const slot = this.shadowRoot.querySelector('slot[name=\"buttons\"]');\n    if (!slot) {\n      console.warn(`NotificationDialog couldn't find its default slot.`);\n      return;\n    }\n    renderArrayAsElements(choices, slot, (choice, button) => {\n      if (!button) {\n        button = document.createElement('button');\n      }\n      button.textContent = choice;\n      return button;\n    });\n  }\n\n  // Let the user select a choice by pressing its initial letter.\n  [symbols.keydown](event) {\n    let handled = false;\n\n    // Loop over choices to see if one of them starts with the key.\n    // TODO: Loop over buttons instead of choices?\n    let found = false;\n    let index = 0;\n    while (index < this.choices.length && !found) {\n      if (this.choices[index].charCodeAt(0) === event.keyCode) {\n        found = true;\n      } else {\n        index++;\n      }\n    }\n    if (found && index >= 0) {\n      this.close(this.choices[index]);\n      handled = true;\n    }\n\n    // Prefer mixin result if it's defined, otherwise use base result.\n    return handled || (super[symbols.keydown] && super[symbols.keydown](event)) || false;\n  }\n\n  /**\n   * An array with a single item: the string \"OK\".\n   * \n   * @type {[string]}\n   */\n  static get OK() {\n    return ['OK'];\n  }\n\n  /**\n   * An array containing two strings: \"OK\" and \"Cancel\".\n   * \n   * @type {[string]}\n   */\n  static get OK_CANCEL() {\n    return ['OK', 'Cancel'];\n  }\n\n  [symbols.template](fillers = {}) {\n    const defaultFiller = typeof fillers === 'string' ?\n      fillers :\n      fillers.default || `<slot></slot>`;\n    const buttonFiller = fillers.buttons || `<slot name=\"buttons\"><button>OK</button></slot>`;\n    return super[symbols.template](`\n      <style>\n        #container {\n          padding: 1em;\n        }\n\n        #buttonContainer {\n          margin-top: 1em;\n        }\n\n        button {\n          font-family: inherit;\n          font-size: inherit;\n        }\n\n        button:not(:first-child) {\n          margin-left: 0.25em;\n        }\n      </style>\n      <div id=\"container\">\n        ${defaultFiller}\n        <div id=\"buttonContainer\">\n          ${buttonFiller}\n        </div>\n      </div>\n    `);\n  }\n\n}\n\n\ncustomElements.define('elix-alert-dialog', AlertDialog);\nexport default AlertDialog;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/AlertDialog.js","import AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\nimport BackdropWrapper from './BackdropWrapper.js';\nimport DialogModalityMixin from '../mixins/DialogModalityMixin.js';\nimport FocusCaptureWrapper from './FocusCaptureWrapper.js';\nimport KeyboardMixin from '../mixins/KeyboardMixin.js';\nimport OpenCloseMixin from '../mixins/OpenCloseMixin.js';\nimport OverlayMixin from '../mixins/OverlayMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport symbols from '../mixins/symbols.js';\nimport TransitionEffectMixin from '../mixins/TransitionEffectMixin.js';\n\n\nconst Base =\n  // Relative order of wrapper application matters: first focus capture\n  // wrapper, then backdrop wrapper. Remaining mixins can be applied in\n  // any order.\n  BackdropWrapper(\n  FocusCaptureWrapper(\n\n  AttributeMarshallingMixin(\n  DialogModalityMixin(\n  KeyboardMixin(\n  OpenCloseMixin(\n  OverlayMixin(\n  ShadowTemplateMixin(\n  TransitionEffectMixin(\n    HTMLElement\n  )))))))));\n\n\n/**\n * A drawer is a modal container generally used to provide navigation in\n * situations where: a) screen real estate is constrained and b) the navigation\n * UI is not critical to completing the user’s primary goal (and, hence, not\n * critical to the application’s business goal).\n * \n * Dialog uses `BackdropWrapper` to add a backdrop behind the main overlay\n * content. Both the backdrop and the dialog itself can be styled.\n * \n * @extends {HTMLElement}\n * @mixes AttributeMarshallingMixin\n * @mixes BackdropWrapper\n * @mixes DialogModalityMixin\n * @mixes FocusCaptureWrapper\n * @mixes KeyboardMixin\n * @mixes OpenCloseMixin\n * @mixes OverlayMixin\n * @mixes ShadowTemplateMixin\n * @mixes TransitionEffectMixin\n */\nclass Drawer extends Base {\n  \n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    // We can't seem to write a CSS rule that lets a shadow element be sensitive\n    // to the `dir` attribute of an ancestor, so we reflect the inherited\n    // direction to the component. We can then write styles that key off of\n    // that.\n    const direction = getComputedStyle(this).direction;\n    if (direction === 'rtl' && !this.dir) {\n      this.setAttribute('dir', 'rtl');\n    }\n  }\n\n  [symbols.elementsWithTransitions](effect) {\n    return [\n      this.backdrop,\n      this.shadowRoot.querySelector('#overlayContent')\n    ];\n  }\n\n  [symbols.shadowCreated]() {\n    if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n\n    // Implicitly close on background clicks.\n    this.backdrop.addEventListener('click', () => {\n      this.close();\n    });\n  }\n\n  [symbols.template](filler) {\n    return super[symbols.template](`\n      <style>\n        :host {\n          display: flex;\n          align-items: stretch;\n          flex-direction: row;\n          justify-content: flex-start;\n        }\n\n        :host(:not(.visible)) {\n          display: none;\n        }\n\n        #backdrop {\n          background: black;\n          opacity: 0;\n          will-change: opacity;\n        }\n\n        :host(.effect) #backdrop {\n          transition: opacity 0.25s linear;\n        }\n        :host(.opened:not(.effect)) #backdrop,\n        :host(.effect.opening) #backdrop {\n          opacity: 0.4;\n        }\n\n        #overlayContent {\n          background: white;\n          border: 1px solid rgba(0, 0, 0, 0.2);\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);\n          transform: translateX(-100%);\n          will-change: transform;\n        }\n        :host([dir=\"rtl\"]) #overlayContent {\n          transform: translateX(100%);\n        }\n\n        :host(.opened:not(.effect)) #overlayContent,\n        :host(.effect.opening) #overlayContent {\n          transform: translateX(0);\n        }\n\n        :host(.effect) #overlayContent {\n          transition: transform 0.25s;\n        }\n        :host(.effect.opening) #overlayContent {\n          transition-timing-function: ease-out;\n        }\n        :host(.effect.closing) #overlayContent {\n          transition-timing-function: ease-in;\n        }\n      </style>\n      ${ filler || `<slot></slot>`}\n    `);\n  }\n\n}\n\n\ncustomElements.define('elix-drawer', Drawer);\nexport default Drawer;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/Drawer.js","import LabeledTabButton from './LabeledTabButton.js';\nimport renderArrayAsElements from '../mixins/renderArrayAsElements.js';\nimport Tabs from './Tabs.js';\nimport symbols from '../mixins/symbols.js';\n\n\n/**\n * A set of tabs with default tab buttons for each tab panel. Each button will\n * have a text label extracted from the `aria-label` attribute of the\n * corresponding panel.\n *\n * This is a specialized version of the more general [Tabs](Tabs) component.\n * It's intended for the common case where the tab buttons just need a text\n * label. The tab buttons will be instances of\n * [LabeledTabButton](LabeledTabButton). If you'd like to use a different\n * element for the tab buttons, you can use the `Tabs` component directly.\n *\n * @extends Tabs\n */\nclass LabeledTabs extends Tabs {\n\n  [symbols.itemsChanged]() {\n    if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n    // Create one tab button for each panel.\n    const tabStrip = this.tabStrip;\n\n    const slot = this.shadowRoot.querySelector('slot[name=\"tabButtons\"]');\n    if (!slot) {\n      console.warn(`LabeledTabs couldn't find a slot named \"tabButtons\".`);\n      return;\n    }\n\n    const tabPosition = this.tabPosition;\n    renderArrayAsElements(this.items, slot, (tabPanel, tabButton) => {\n      if (!tabButton || !(tabButton instanceof LabeledTabButton)) {\n        tabButton = new LabeledTabButton();\n        tabButton.setAttribute('tabindex', 0);\n        tabButton.setAttribute('tab-position', tabPosition);\n      }\n      tabButton.id = tabPanel.id + '_tab';\n      tabButton.textContent = tabPanel.getAttribute('aria-label');\n\n      // Point the tab button and tab panel at each other.\n      tabButton.setAttribute('aria-controls', tabPanel.id);\n      tabPanel.setAttribute('aria-labelledby', tabButton.id);\n\n      return tabButton;\n    });\n\n    tabStrip.selectedIndex = this.selectedIndex;\n  }\n\n  // HACK: A bug in WebKit and Blink prevents TabStrip from correctly applying\n  // styling to a slot's default nodes. See\n  // https://github.com/w3c/webcomponents/issues/631. This bug comes into play\n  // when a LabeledTabs component has tabAlign set to \"stretch\". We work around\n  // this bug by adding a style rule that explicitly styles slot children.\n  [symbols.template](fillers) {\n    const defaultFiller = typeof fillers === 'string' ?\n      fillers :\n      (fillers && fillers.default) || `<slot></slot>`;\n    const tabButtonsFiller = fillers && fillers.tabButtons;\n    /* Styling workaround: see note above */\n    const template = `\n      ${defaultFiller}\n      <style>\n        :host([tab-align=\"stretch\"]) slot[name=\"tabButtons\"] > * {\n          flex: 1;\n        }\n      </style>\n    `;\n    return super[symbols.template]({\n      default: template,\n      tabButtons: tabButtonsFiller\n    });\n  }\n\n}\n\n\ncustomElements.define('elix-labeled-tabs', LabeledTabs);\nexport default LabeledTabs;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/LabeledTabs.js","import AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\nimport ClickSelectionMixin from '../mixins/ClickSelectionMixin.js';\nimport ContentItemsMixin from '../mixins/ContentItemsMixin.js';\nimport DefaultSlotContentMixin from '../mixins/DefaultSlotContentMixin.js';\nimport DirectionSelectionMixin from '../mixins/DirectionSelectionMixin.js';\nimport KeyboardDirectionMixin from '../mixins/KeyboardDirectionMixin.js';\nimport KeyboardMixin from '../mixins/KeyboardMixin.js';\nimport KeyboardPagedSelectionMixin from '../mixins/KeyboardPagedSelectionMixin.js';\nimport KeyboardPrefixSelectionMixin from '../mixins/KeyboardPrefixSelectionMixin.js';\nimport SelectedItemTextValueMixin from '../mixins/SelectedItemTextValueMixin.js';\nimport SelectionAriaMixin from '../mixins/SelectionAriaMixin.js';\nimport SelectionInViewMixin from '../mixins/SelectionInViewMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport SingleSelectionMixin from '../mixins/SingleSelectionMixin.js';\nimport symbols from '../mixins/symbols.js';\nimport { toggleClass } from '../mixins/attributes.js';\n\n\nconst Base =\n  AttributeMarshallingMixin(\n  ClickSelectionMixin(\n  ContentItemsMixin(\n  DefaultSlotContentMixin(\n  DirectionSelectionMixin(\n  KeyboardDirectionMixin(\n  KeyboardMixin(\n  KeyboardPagedSelectionMixin(\n  KeyboardPrefixSelectionMixin(\n  SelectedItemTextValueMixin(\n  SelectionAriaMixin(\n  SelectionInViewMixin(\n  ShadowTemplateMixin(\n  SingleSelectionMixin(\n    HTMLElement\n  ))))))))))))));\n\n\n/**\n * A simple single-selection list box.\n *\n * This component supports a generic visual style, ARIA support, and full\n * keyboard navigation. See `KeyboardDirectionMixin`,\n * `KeyboardPagedSelectionMixin`, and `KeyboardPrefixSelectionMixin` for\n * keyboard details.\n *\n * @extends {HTMLElement}\n * @mixes AttributeMarshallingMixin\n * @mixes ClickSelectionMixin\n * @mixes ContentItemsMixin\n * @mixes DefaultSlotContentMixin\n * @mixes DirectionSelectionMixin\n * @mixes KeyboardDirectionMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardPagedSelectionMixin\n * @mixes KeyboardPrefixSelectionMixin\n * @mixes SelectedItemTextValueMixin\n * @mixes SelectionAriaMixin\n * @mixes SelectionInViewMixin\n * @mixes ShadowTemplateMixin\n * @mixes SingleSelectionMixin\n */\nclass ListBox extends Base {\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    // By default, we assume the list presents list items vertically.\n    defaults.orientation = 'vertical';\n    return defaults;\n  }\n\n  // Map item selection to a `selected` CSS class.\n  /**\n   * @param {Element} item \n   * @param {boolean} selected \n   */\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    toggleClass(item, 'selected', selected);\n  }\n\n  /**\n   * The vertical (default) or horizontal orientation of the list.\n   *\n   * Supported values are \"horizontal\" or \"vertical\".\n   *\n   * @type {string}\n   */\n  get orientation() {\n    return this[symbols.orientation] || this[symbols.defaults].orientation;\n  }\n  set orientation(value) {\n    const changed = value !== this[symbols.orientation];\n    this[symbols.orientation] = value;\n    // @ts-ignore\n    if ('orientation' in Base) { super.orientation = value; }\n    // Reflect attribute for styling\n    this.reflectAttribute('orientation', value);\n    if (changed && this[symbols.raiseChangeEvents]) {\n      const event = new CustomEvent('orientation-changed');\n      this.dispatchEvent(event);\n    }\n  }\n\n  [symbols.template](filler) {\n    return `\n      <style>\n      :host {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      #itemsContainer {\n        flex: 1;\n        -webkit-overflow-scrolling: touch; /* for momentum scrolling */\n        overflow-x: hidden;\n        overflow-y: scroll;\n      }\n      :host([orientation=\"horizontal\"]) #itemsContainer {\n        display: flex;\n        overflow-x: scroll;\n        overflow-y: hidden;\n      }\n\n      #itemsContainer ::slotted(*) {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      #itemsContainer ::slotted(.selected) {\n        background: var(--elix-selected-background, highlight);\n        color: var(--elix-selected-color, highlighttext);\n      }\n      </style>\n\n      <div id=\"itemsContainer\" role=\"none\">\n        ${filler || `<slot></slot>`}\n      </div>\n    `;\n  }\n\n  /**\n   * Fires when the orientation property changes in response to internal\n   * component activity.\n   *\n   * @memberof ListBox\n   * @event orientation-changed\n   */\n}\n\n\ncustomElements.define('elix-list-box', ListBox);\nexport default ListBox;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/ListBox.js","import AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\nimport KeyboardMixin from '../mixins/KeyboardMixin.js';\nimport OpenCloseMixin from '../mixins/OpenCloseMixin.js';\nimport OverlayMixin from '../mixins/OverlayMixin.js';\nimport PopupModalityMixin from '../mixins/PopupModalityMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport symbols from '../mixins/symbols.js';\n\n\nconst Base =\n  AttributeMarshallingMixin(\n  KeyboardMixin(\n  OpenCloseMixin(\n  OverlayMixin(\n  PopupModalityMixin(\n  ShadowTemplateMixin(\n    HTMLElement\n  ))))));\n\n\n/**\n * A `Popup` is a lightweight form of overlay that, when opened, displays its\n * children on top of other page elements.\n * \n * @extends {HTMLElement}\n * @mixes AttributeMarshallingMixin\n * @mixes KeyboardMixin\n * @mixes OpenCloseMixin\n * @mixes OverlayMixin\n * @mixes PopupModalityMixin\n * @mixes ShadowTemplateMixin\n */\nclass Popup extends Base {\n\n  [symbols.template](filler) {\n    return `\n      <style>\n        :host {\n          align-items: center;\n          display: flex;\n          flex-direction: column;\n          height: 100%;\n          justify-content: center;\n          left: 0;\n          outline: none;\n          pointer-events: none;\n          position: fixed;\n          top: 0;\n          width: 100%;\n        }\n\n        :host(:not(.visible)) {\n          display: none;\n        }\n\n        #overlayContent {\n          background: white;\n          border: 1px solid rgba(0, 0, 0, 0.2);\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);\n          pointer-events: initial;\n        }\n      </style>\n      <div id=\"overlayContent\">\n        ${filler || `<slot></slot>`}\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('elix-popup', Popup);\nexport default Popup;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/Popup.js","import AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\nimport OpenCloseMixin from '../mixins/OpenCloseMixin.js';\nimport OverlayMixin from '../mixins/OverlayMixin.js';\nimport ShadowTemplateMixin from '../mixins/ShadowTemplateMixin.js';\nimport Symbol from '../mixins/Symbol.js';\nimport symbols from '../mixins/symbols.js';\nimport TransitionEffectMixin from '../mixins/TransitionEffectMixin.js';\n\n\nconst durationKey = Symbol('duration');\nconst fromEdgeKey = Symbol('fromEdge');\nconst timeoutKey = Symbol('timeout');\n\n\nconst Base =\n  AttributeMarshallingMixin(\n  OpenCloseMixin(\n  OverlayMixin(\n  ShadowTemplateMixin(\n  TransitionEffectMixin(\n    HTMLElement\n  )))));\n\n\n/**\n * A lightweight popup intended to display a short, non-critical message until a\n * specified `duration` elapses or the user dismisses it.\n * \n * @extends {HTMLElement}\n * @mixes AttributeMarshallingMixin\n * @mixes OpenCloseMixin\n * @mixes OverlayMixin\n * @mixes ShadowTemplateMixin\n * @mixes TransitionEffectMixin\n */\nclass Toast extends Base {\n\n  constructor() {\n    super();\n\n    // If the user moves the mouse over the element, stop the timer.\n    this.addEventListener('mouseover', () => {\n      clearTimer(this);\n    });\n\n    // If the user moves the mouse away, restart the timer.\n    this.addEventListener('mouseout', () => {\n      startTimer(this);\n    });\n\n    // Set defaults.\n    if (typeof this.duration === 'undefined') {\n      this.duration = this[symbols.defaults].duration;\n    }\n    if (typeof this.fromEdge === 'undefined') {\n      this.fromEdge = this[symbols.defaults].fromEdge;\n    }\n  }\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    \n    // Set default ARIA role for the popup.\n    if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n      this.setAttribute('role', this[symbols.defaults].role);\n    }\n\n    // We can't seem to write a CSS rule that lets a shadow element be sensitive\n    // to the `dir` attribute of an ancestor, so we reflect the inherited\n    // direction to the component. We can then write styles that key off of\n    // that.\n    const direction = getComputedStyle(this).direction;\n    if (direction === 'rtl' && !this.dir) {\n      this.setAttribute('dir', 'rtl');\n    }\n  }\n\n  [symbols.afterEffect](effect) {\n    if (super[symbols.afterEffect]) { super[symbols.afterEffect](effect); }\n    switch (effect) {\n      case 'opening':\n        startTimer(this);\n        break;\n    }\n  }\n\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    defaults.duration = 2500; /* milliseconds */\n    defaults.fromEdge = 'bottom';\n    defaults.role = 'alert';\n    return defaults;\n  }\n\n  /**\n   * This property specifies in milliseconds how long a toast should remain open\n   * before being implicitly closed. The default value is 2500 milliseconds (2.5\n   * seconds).\n   * \n   * To support interactivity within a toast, the timer is disabled if the user\n   * moves the mouse inside the toast or taps within it. When/if the user later\n   * moves the mouse outside the toast, or taps outside it, the timer will be\n   * restarted at zero.\n   * \n   * Setting `duration` to `null` will disable the timer, allowing the toast to\n   * remain open indefinitely.\n   * \n   * @type {number}\n   * @default 2500\n   */\n  get duration() {\n    return this[durationKey];\n  }\n  /**\n   * @param {number} duration - The duration to show the toast, in milliseconds\n   */\n  set duration(duration) {\n    this[durationKey] = typeof duration === 'string' ? parseInt(duration) : duration;\n  }\n\n  [symbols.elementsWithTransitions](effect) {\n    return [this.shadowRoot.querySelector('#overlayContent')];\n  }\n\n  /**\n   * The `fromEdge` property determines the edge from which the toast will slide\n   * into view. Supported values are:\n   * \n   * * \"bottom\" (the default): slides in from the center of the bottom of the\n   *   window.\n   * * \"bottom-left\"\n   * * \"bottom-right\"\n   * * \"top\"\n   * * \"top-left\"\n   * * \"top-right\"\n   * \n   * The `Toast` component supports right-to-left languages such as Arabic and\n   * Hebrew. If the effective value of the element’s `dir` attribute is set to\n   * \"rtl\" (right to left), then the interpretation of the `fromEdge` property\n   * will be flipped horizontally: for example, setting `from-edge=“top-right”`\n   * will cause the `Toast` to appear from the top _left_.\n   *\n   * @type {\"bottom\"|\"bottom-left\"|\"bottom-right\"|\"top\"|\"top-left\"|\"top-right\"|null}\n   */\n  get fromEdge() {\n    return this[fromEdgeKey];\n  }\n  set fromEdge(fromEdge) {\n    this[fromEdgeKey] = fromEdge;\n    this.reflectAttribute('from-edge', fromEdge);\n  }\n\n  [symbols.openedChanged](opened) {\n    if (!opened) {\n      clearTimer(this);\n    }\n  }\n\n  [symbols.template](filler) {\n    return `\n      <style>\n        :host {\n          display: flex;\n          flex-direction: column;\n          height: 100%;\n          left: 0;\n          outline: none;\n          pointer-events: none;\n          position: fixed;\n          top: 0;\n          width: 100%;\n        }\n\n        :host(:not(.visible)) {\n          display: none;\n        }\n\n        #overlayContent {\n          background: white;\n          border: 1px solid rgba(0, 0, 0, 0.2);\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);\n          margin: 1em;\n          opacity: 0;\n          pointer-events: initial;\n          will-change: opacity, transform;\n        }\n\n        :host(.opened:not(.effect)) #overlayContent,\n        :host(.effect.opening) #overlayContent {\n          opacity: 1.0;\n        }\n\n        :host(.effect) #overlayContent {\n          transition-duration: 0.25s;\n          transition-property: opacity, transform;\n        }\n        :host(.effect.opening) #overlayContent {\n          transition-timing-function: ease-out;\n        }\n        :host(.effect.closing) #overlayContent {\n          transition-timing-function: ease-in;\n        }\n\n        /* From bottom edge (the default) */\n        :host([from-edge=\"bottom\"]) {\n          align-items: center;\n          justify-content: flex-end;\n        }\n        :host([from-edge=\"bottom\"]) #overlayContent {\n          transform: translateY(100%);\n        }\n        :host([from-edge=\"bottom\"].opened:not(.effect)) #overlayContent,\n        :host([from-edge=\"bottom\"].effect.opening) #overlayContent {\n          transform: translateY(0);\n        }\n\n        /* From bottom-left corner */\n        :host([from-edge=\"bottom-left\"]) {\n          align-items: flex-start;\n          justify-content: flex-end;\n        }\n        :host([from-edge=\"bottom-left\"]) #overlayContent {\n          transform: translateX(-100%);\n        }\n        :host([from-edge=\"bottom-left\"][dir=\"rtl\"]) #overlayContent {\n          transform: translateX(100%);\n        }\n        :host([from-edge=\"bottom-left\"].opened:not(.effect)) #overlayContent,\n        :host([from-edge=\"bottom-left\"].effect.opening) #overlayContent {\n          transform: translateX(0);\n        }\n\n        /* From bottom-right corner */\n        :host([from-edge=\"bottom-right\"]) {\n          align-items: flex-end;\n          justify-content: flex-end;\n        }\n        :host([from-edge=\"bottom-right\"]) #overlayContent {\n          transform: translateX(100%);\n        }\n        :host([from-edge=\"bottom-right\"][dir=\"rtl\"]) #overlayContent {\n          transform: translateX(-100%);\n        }\n        :host([from-edge=\"bottom-right\"].opened:not(.effect)) #overlayContent,\n        :host([from-edge=\"bottom-right\"].effect.opening) #overlayContent {\n          transform: translateX(0);\n        }\n\n        /* From top edge */\n        :host([from-edge=\"top\"]) {\n          align-items: center;\n        }\n        :host([from-edge=\"top\"]) #overlayContent {\n          transform: translateY(-100%);\n        }\n        :host([from-edge=\"top\"].opened:not(.effect)) #overlayContent,\n        :host([from-edge=\"top\"].effect.opening) #overlayContent {\n          transform: translateY(0);\n        }\n\n        /* From top-left corner */\n        :host([from-edge=\"top-left\"]) {\n          align-items: flex-start;\n        }\n        :host([from-edge=\"top-left\"]) #overlayContent {\n          transform: translateX(-100%);\n        }\n        :host([from-edge=\"top-left\"][dir=\"rtl\"]) #overlayContent {\n          transform: translateX(100%);\n        }\n        :host([from-edge=\"top-left\"].opened:not(.effect)) #overlayContent,\n        :host([from-edge=\"top-left\"].effect.opening) #overlayContent {\n          transform: translateX(0);\n        }\n\n        /* From top-right corner */\n        :host([from-edge=\"top-right\"]) {\n          align-items: flex-end;\n        }\n        :host([from-edge=\"top-right\"]) #overlayContent {\n          transform: translateX(100%);\n        }\n        :host([from-edge=\"top-right\"][dir=\"rtl\"]) #overlayContent {\n          transform: translateX(-100%);\n        }\n        :host([from-edge=\"top-right\"].opened:not(.effect)) #overlayContent,\n        :host([from-edge=\"top-right\"].effect.opening) #overlayContent {\n          transform: translateX(0);\n        }\n      </style>\n      <div id=\"overlayContent\">\n        ${filler || `<slot></slot>`}\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('elix-toast', Toast);\nexport default Toast;\n\n\nfunction clearTimer(element) {\n  if (element[timeoutKey]) {\n    clearTimeout(element[timeoutKey]);\n    element[timeoutKey] = null;\n  }\n}\n\nfunction startTimer(element) {\n  clearTimer(element);\n  const duration = element.duration;\n  if (duration != null && duration > 0) {\n    element[timeoutKey] = setTimeout(() => {\n      element[symbols.raiseChangeEvents] = true;\n      element.close();\n      element[symbols.raiseChangeEvents] = false;\n    }, duration);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/Toast.js","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Elix global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\n\n// Import mixins\nimport * as attributes from './mixins/attributes.js';\nimport * as content from './mixins/content.js';\nimport AttributeMarshallingMixin from './mixins/AttributeMarshallingMixin.js';\nimport ClickSelectionMixin from './mixins/ClickSelectionMixin.js';\nimport constants from './mixins/constants.js';\nimport ContentItemsMixin from './mixins/ContentItemsMixin.js';\nimport defaultScrollTarget from './mixins/defaultScrollTarget.js';\nimport DefaultSlotContentMixin from './mixins/DefaultSlotContentMixin.js';\nimport DirectionSelectionMixin from './mixins/DirectionSelectionMixin.js';\nimport KeyboardDirectionMixin from './mixins/KeyboardDirectionMixin.js';\nimport KeyboardMixin from './mixins/KeyboardMixin.js';\nimport KeyboardPagedSelectionMixin from './mixins/KeyboardPagedSelectionMixin.js';\nimport KeyboardPrefixSelectionMixin from './mixins/KeyboardPrefixSelectionMixin.js';\nimport OpenCloseMixin from './mixins/OpenCloseMixin.js';\nimport OverlayMixin from './mixins/OverlayMixin.js';\nimport renderArrayAsElements from './mixins/renderArrayAsElements.js';\nimport SelectionAriaMixin from './mixins/SelectionAriaMixin.js';\nimport SelectionInViewMixin from './mixins/SelectionInViewMixin.js';\nimport ShadowReferencesMixin from './mixins/ShadowReferencesMixin.js';\nimport ShadowTemplateMixin from './mixins/ShadowTemplateMixin.js';\nimport SingleSelectionMixin from './mixins/SingleSelectionMixin.js';\nimport Symbol from './mixins/Symbol.js';\nimport symbols from './mixins/symbols.js';\nimport TransitionEffectMixin from './mixins/TransitionEffectMixin.js';\n\n// Import elements\nimport AlertDialog from './elements/AlertDialog.js';\nimport Dialog from './elements/Dialog.js';\nimport Drawer from './elements/Drawer.js';\nimport LabeledTabButton from './elements/LabeledTabButton.js';\nimport LabeledTabs from './elements/LabeledTabs.js';\nimport ListBox from './elements/ListBox.js';\nimport Modes from './elements/Modes.js';\nimport Popup from './elements/Popup.js';\nimport Tabs from './elements/Tabs.js';\nimport TabStrip from './elements/TabStrip.js';\nimport TabStripWrapper from './elements/TabStripWrapper.js';\nimport Toast from './elements/Toast.js';\n\n\n// The complete list of all mixins and elements.\nconst Elix = {\n  AttributeMarshallingMixin,\n  attributes,\n  ClickSelectionMixin,\n  constants,\n  content,\n  ContentItemsMixin,\n  defaultScrollTarget,\n  DefaultSlotContentMixin,\n  Dialog,\n  DirectionSelectionMixin,\n  Drawer,\n  KeyboardDirectionMixin,\n  KeyboardMixin,\n  KeyboardPagedSelectionMixin,\n  KeyboardPrefixSelectionMixin,\n  LabeledTabButton,\n  LabeledTabs,\n  ListBox,\n  Modes,\n  AlertDialog,\n  OpenCloseMixin,\n  OverlayMixin,\n  Popup,\n  renderArrayAsElements,\n  SelectionAriaMixin,\n  SelectionInViewMixin,\n  ShadowReferencesMixin,\n  ShadowTemplateMixin,\n  SingleSelectionMixin,\n  Symbol,\n  symbols,\n  Tabs,\n  TabStrip,\n  TabStripWrapper,\n  TransitionEffectMixin,\n  Toast\n};\n\n\n// Create (or add to) Elix global.\nwindow.Elix = Object.assign(window.Elix || {}, Elix);\n\n\nexport default Elix;\n\n\n\n// WEBPACK FOOTER //\n// ./globals.js","import Symbol from '../mixins/Symbol.js';\nimport symbols from './symbols.js';\n\n\n// Symbols for private data members on an element.\nconst closeListenerKey = Symbol('closeListener');\n\n\n/**\n * This mixin makes an overlay behave like a popup by dismissing it when certain\n * user interactions occur.\n * \n * This mixin expects the component to provide:\n * \n * * An open/close API compatible with `OpenCloseMixin`.\n * \n * The mixin provides these features to the component:\n * \n * * Event handlers that close the element if the user clicks outside the\n *   element, presses the Esc key, moves the focus outside the element, scrolls\n *   the document, resizes the document, or switches focus away from the\n *   document.\n * * A default ARIA role of `alert`.\n * \n * For modal overlays, use `DialogModalityMixin` instead. See the documentation\n * of that mixin for a comparison of modality behaviors.\n * \n * @module PopupModalityMixin\n */\nexport default function PopupModalityMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class PopupModality extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n      // Implicitly close on loss of focus.\n      this.addEventListener('blur', () => {\n        this[symbols.raiseChangeEvents] = true;\n        this.close();\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the popup.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'alert';\n      return defaults;\n    }\n\n    // Close on Esc key.\n    [symbols.keydown](event) {\n      let handled = false;\n\n      switch (event.keyCode) {\n        case 27: // Escape\n          this.close();\n          handled = true;\n          break;\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event)) || false;\n    }\n\n    [symbols.openedChanged](opened) {\n      if (super[symbols.openedChanged]) { super[symbols.openedChanged](opened); }\n      if (opened) {\n\n        // General purpose listener for events that happen outside the\n        // component.\n        this[closeListenerKey] = event => {\n          const insideEvent = this === event.target ||\n            (event.target instanceof Node && this.contains(event.target));\n          if (!insideEvent) {\n            this[symbols.raiseChangeEvents] = true;\n            this.close();\n            this[symbols.raiseChangeEvents] = false;\n          }\n        };\n\n        // Wait a tick before wiring up events — if the popup was opened\n        // because the user clicked something, that opening click event may\n        // still be bubbling up, and we only want to start listening after\n        // it's been processed.\n        setTimeout(() => {\n          // It's conceivable the popup was closed before the timeout completed,\n          // so double-check that it's still opened before listening to events.\n          if (this.opened) {\n            document.addEventListener('click', this[closeListenerKey]);\n            document.addEventListener('keydown', this[closeListenerKey]);\n            window.addEventListener('blur', this[closeListenerKey]);\n            window.addEventListener('resize', this[closeListenerKey]);\n            window.addEventListener('scroll', this[closeListenerKey]);\n          }\n        });\n      } else {\n        // Stop closing on window blur/resize/scroll.\n        document.removeEventListener('click', this[closeListenerKey]);\n        document.removeEventListener('keydown', this[closeListenerKey]);\n        window.removeEventListener('blur', this[closeListenerKey]);\n        window.removeEventListener('resize', this[closeListenerKey]);\n        window.removeEventListener('scroll', this[closeListenerKey]);\n      }\n    }\n  }\n\n  return PopupModality;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/PopupModalityMixin.js","import symbols from './symbols.js';\n\n\n/**\n * Mixin which defines a `value` property that reflects the text content of a\n * selected item.\n *\n * This mixin exists for list-like components that want to provide a more\n * convenient way to get/set the selected item using text. It adds a `value`\n * property that gets the `textContent` of a component's `selectedItem`. The\n * `value` property can also be set to set the selection to the first item in\n * the `items` collection that has the requested `textContent`. If the indicated\n * text is not found in `items`, the selection is cleared.\n *\n * This mixin expects a component to provide an `items` array of all elements\n * in the list. A standard way to do that with is\n * [ContentItemsMixin](ContentItemsMixin). This also expects the definition\n * of `selectedIndex` and `selectedItem` properties, which can be obtained\n * from [SingleSelectionMixin](SingleSelectionMixin).\n *\n * @module SelectedItemTextValueMixin\n */\nexport default function SelectedItemTextValueMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class SelectedItemTextValue extends Base {\n\n    /**\n     * The text content of the selected item.\n     *\n     * Setting this value to a string will attempt to select the first list item\n     * whose text content match that string. Setting this to a string not matching\n     * any list item will result in no selection.\n     *\n     * @type {string}\n     */\n    get value() {\n      return this.selectedItem == null || this.selectedItem.textContent == null ?\n        '' :\n        this.selectedItem.textContent;\n    }\n    set value(text) {\n\n      const currentIndex = this.selectedIndex;\n      let newIndex = -1; // Assume we won't find the text.\n\n      // Find the item with the indicated text.\n      const items = this.items;\n      if (items == null) {\n        return;\n      }\n      for (let i = 0, length = items.length; i < length; i++) {\n        if (items[i].textContent === text) {\n          newIndex = i;\n          break;\n        }\n      }\n\n      if (newIndex !== currentIndex) {\n        this.selectedIndex = newIndex;\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('value-changed');\n          this.dispatchEvent(event);\n        }\n      }\n    }\n  }\n\n  return SelectedItemTextValue;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./mixins/SelectedItemTextValueMixin.js"],"sourceRoot":""}